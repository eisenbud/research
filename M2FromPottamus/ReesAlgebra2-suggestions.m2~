----------
--Suggestions (OLD as of Nov 26, 09).
--specialFiberideal i
--should return an ideal in a ring with only the "new" variables
--resolutions can still be AWFUL over tower rings!
{*
S=kk[x,y,z,u]
j=ideal(x^3,y^3,z^3,u^3,x*y*z+x*y*u)
jR=reesIdeal j
f=(flattenRing jR)_1
time res (f jR) -- less than .01 sec
time res jR --more than 100 sec (I didn't wait.)
*}
---------

--NEW (12/13/08)
--there should be "symmetricAlgebraIdea" and "normalConeIdeal" functions,
--the functions "minimal reduction", "reduction number",  "whichGm",
--"jacobianDualMatrix" and "ExpectedReesIdeal"
--below should be added to the ReesAlgebra2.m2 package.


--Useful code



needsPackage "ReesAlgebra2"

--not yet anywhere:
minimalReduction = i ->(
     S:=ring i;
     ell:=analyticSpread i;
     if isHomogeneous i and (d:=min degrees i) == max degrees i then
     ideal ((gens i)*random(source gens i, (ring i)^{ell:-d})) else 
     (
	  print"Warning: minimal reduction is not necessarily homogeneous";
     	  ideal (map(S^1, S^(rank source gens i), gens i)*random(S^(rank source gens i), S^ell))
     ))

reductionNumber = method();
reductionNumber(Ideal):= i ->(
     J:=minimalReduction i;
     rN:=0;
     while not ((gens (i^(1+rN)))%(i^(rN)*J)) ==0 do (
     	  rN =rN+1);
     rN)

whichGm = i ->(
     --This *probabilistic* procedure returns the largest number m for which the ideal i satsifies
     --the condition
     --
     --G_m: i_P is generated by <= codim P elements for all P with codim P < m.
     --
     f:=presentation module i;
     S:=ring f;
     if f==0 then "infinity" else(
     q:=rank target f;
     maxSource := (max degrees source f)_0;
     minTarget := (min degrees target f)_0;
     randomMinor := (f,t)->(
	  if t<=0 then ideal(1_S) else
	  if t >min(rank source f, rank target f) then ideal(0_S) else
	   ideal det (random(S^{t:-minTarget},target f)*f*random(source f, S^{t:-maxSource})));
     d:=dim ring i;
     m:=codim i;
     j:=i+randomMinor(f,q-m);
          while m<d+1 and codim j > m do (
	       m=m+1;
	       j=j+randomMinor(f, q-m));
     if m<=d then m else "infinity"))

--the following code makes an ideal with random generators
--with a specified list L of degrees, taken from an ideal I.


///
restart
load "ReesAlgebra2-suggestions.m2"
load "randomIdeal.m2"
kk=ZZ/101
S=kk[a..c]
L={3,4,5,6,7,8,9}
i=randomIdeal(matrix{{a..c}}, L)
f=syz gens i
time whichGm i
///

global w;
jacobianDualMatrix = method(Options=>{Variable => global w})
jacobianDualMatrix(Matrix,Ideal) := Matrix => o -> (M,I) -> (
--takes a matrix M, thought of as the presentation matrix of an ideal, 
--and an ideal I containing the 1 x 1 minors of M, and returns
--a ``Jacobian Dual matrix'' B, over a ring with an additional set of
-- subscripted variables corresponding to the rows of M, such that
--if $(m_0..m_s)$ are generators for $I$, and the new
--variables are w_1..w_c, then(w1,...,w_c)*M = (m_1,...,m_s)*B.
--The name of the new variables may be specified by the user (default "w").     
--The significance of the matrix B is that if $M$ is the presentation
--matrix of an ideal i of depth at least 1, then the $s\times s$ minors of B
--are contained in the ideal of the Rees algebra of i.
T:=(ring M)[o.Variable_0..o.Variable_(rank target M-1)];
N:=substitute(M,T);
--oldVars:=sort(mingens minors(1,N), MonomialOrder=>Descending);
newVars:=vars T;
B:=(newVars*N)//oldVars;
ideal(newVars*N)+minors(rank source oldVars, B)
)

jacobianDualMatrix(Matrix) := Matrix => o -> (M) -> (
--equivalent to the call
--jacobianDualMatrix(M, minors(1,M))
T:=(ring M)[o.Variable_0..o.Variable_(rank target M-1)];
N:=substitute(M,T);
IT:=gens substitute(I,T);
newVars:=vars T;
(newVars*N)//IT;
)

expectedReesIdeal = method(Options=>{Variable => global w})
expectedReesIdeal(Matrix, Matrix) := Matrix => o -> (M) -> (
--takes the presentation matrix M of a module, and a Jacobian Dual matrix B, and returns
--the ideal of the symmetric algebra plus the correct size minors
--of a ``Jacobian Dual matrix'' B. If i has depth at least 1 then
--this ideal is at least
--contained in the ideal of the Rees algebra of i, 
--and is sometimes equal to it.
T:=(ring M)[o.Variable_0..o.Variable_(rank target M-1)];
N:=substitute(M,T);
--oldVars:=sort(mingens minors(1,N), MonomialOrder=>Descending);
newVars:=vars T;
B:=(newVars*N)//oldVars;
ideal(newVars*N)+minors(rank source oldVars, B)
)

///
restart
load "ReesAlgebra2-suggestions.m2"

kk=ZZ/101
n:=3
S=kk[a_0..a_(n-1)]
M=catalecticant(4,3,S)
M=random(S^4, S^{3:-1})
D=jacobianDualMatrix(M, Variable=>z)
i=minors(3,M)
J=reesIdeal(i,i_0)
betti res J
betti res D
use ring J
W=matrix{{w_0,w_1,w_2,w_3}}
ring D
f=map(ring J, ring D, W)
f D == J
oldVars=sort(mingens minors(1,M), MonomialOrder=>Descending)
W*M
M
W
///


randomIdealElements=(I,L)->(
ideal((gens I)*random(source gens I, (ring I)^(-L))))

catalecticant = (r,s, S) -> (
     n:=numgens S;
     map(S^r, S^{s:-1}, (i,j)->if i+j<n then S_(i+j) else 0_S)
     )
catalecticantFromIdeal = (r,s,I,d) -> (
     J:=gens randomIdealElements(toList(r+s:d), I);
     map(S^r, S^{s:-1}, (i,j)->J_(i+j))
     )

end  

-------Examples, following Ulrich's suggestions
{*
Definition: An ideal $i \subset S$ satisfies $G_m$ if the localization $i_P$ is
generated by <= height P elements for every prime P of height
at most m-1. Equivalently, 
for j <= m-1, the presentation matrix $f: S^p \to S^q$
of i satisfies $height(I_{q-j}(f)) > j$, where $I_t(f)$ is the ideal
of $t\times t$ minors of $f$. If $i$ satisfies $G_m$ for $m=1+dim S$,
then we say that $I$ satisfies $G_\infty$.

Definition (Huneke): An ideal i=(g_1,..g_t) \subset S is 
\emph{strongly Cohen-Macaulay }
if it is generically a complete
intersection and if each homology group $H_i(K(g_1,\dots,g_t))$
of the Koszul complex of the $g_i$ is a Cohen-Macaulay module.
See Huneke, Craig
Strongly Cohen-Macaulay schemes and residual intersections.
Trans. Amer. Math. Soc. 277 (1983), no. 2, 739--763. 

It is known that licci ideals (codimension 2 perfect ideals, codimension 3
Gorenstein ideals...) are strongly Cohen-Macaulay.

The papers 
Herzog, J.,Simis, A., and  Vasconcelos, W. V. :
Approximation complexes of blowing-up rings.  J. Algebra  74  (1982), no. 2, 466--493. and
Approximation complexes of blowing-up rings. II.  J. Algebra  82  (1983),  no. 1, 53--83.

prove:

Theorem: For a strongly Cohen-Macaulay ideal $i$
$$
G_\infty  \Rightleftarrow \{linear type and the Rees alg is Cohen-Macaulay\}
$$

Also, the paper 
Morey, Susan, and  Ulrich, Bernd, 
Rees algebras of ideals with low codimension. 
Proc. Amer. Math. Soc. 124 (1996), no. 12, 3653--3661. 


*}
restart
load "ReesAlgebra2-suggestions.m2"


kk=ZZ/101
n:=5
S=kk[a_0..a_(n-1)]
L=for t from 2 to n-1 list i=minors(t, catalecticant(t,t+1,S))
L/codim
L/whichGm
L/reductionNumber
L/analyticSpread 
I=L/(s->reesIdeal(s,s_0))
I/(i->(codim i, length(res i)))

m=catalecticant(3,4, S)
i=minors (3,m)
whichGm i
i=minors(5, random(S^5, S^{6:-1}))
whichGm i
time I=reesIdeal( i,i_0)

--------------------------
--Another kind of example
kk=ZZ/101
S=kk[a..d]
m=random(S^3, S^{4:-1})
i=minors (3,m)
analyticSpread i -- 3 in 3 vars, but 4 in 4 AND in 5 vars.
--J=ideal ((gens i)*random(source gens i, S^{4:-3}))
r=reductionNumber i


isLinearType i
--with generic 3x4 in 4 or 5 vars, 
--this gives zero when red number = r is 2, and then i is lin type.
--but in 3 vars, it's not of lin type, and reduct # is 3

normalConeIdeal i
GRi=ideal presentation normalCone i
betti(FF= res GRi, Weights =>{-2,1})
--It *is CM 
codim GRi
degrees vars (flattenRing ring GRi)_0
FF.dd_1


--------
restart
load "ReesAlgebra2-suggestions.m2"
kk=ZZ/101
S=kk[a..d]
--Both generic n x n-1 and catalecticant n x n-1 seem to be linear type.
L=for n from 2 to 4 list (
     M = random(S^{n:-n-1}, S^{n-1:-n-2});
     i=minors(n-1, M));
L/analyticSpread
-- is the analytic spread of the max minors of
--a random n x n-1 equal to min(n, number of variables)?
L/reductionNumber
--But the reduction number seems always 0
L/whichGm -- and they satisfy G_\infty
LR=L/(i->reesAlgebraIdeal(i,i_0)
LR/(i->(codim i, length(res i)))

L=for n from 2 to 4 list (
     M = catalecticant(n-1,n,S);
     i=minors(n-1, M));
L/analyticSpread
-- is the analytic spread of the max minors of
--a random n x n-1 equal to min(n, number of variables)?
L/reductionNumber
--But the reduction number seems always 0
time (L/whichGm) -- all infty
time LR=L/(i->reesIdeal(i,i_0)) 
LR/(i->(codim i, length(res i)))-- all Cohen_Macaulay

-------
L=for n from 2 to 4 list (
     M = random(S^n, S^{-n..-2});
     i=minors(n-1, M));
L/whichGm --all infty
L/analyticSpread -- 1,0,0
L/reductionNumber -- 0,0,0
LR=L/(i->reesAlgebraIdeal(i,i_0)
LR/(i->(codim i, length(res i)))

---
--Make an n x n matrix where the first i rows
--are made from the first i+A_i elements of a give vector X of forms
restart
load "ReesAlgebra2-suggestions.m2"

kk=ZZ/101
A={1,2,2,3}
S=kk[a_1..a_(last A+#A)]
X=vars S

sMatrix = (A,X)->(
     --Let n = #A. Produces an n x n-1 matrix where the first i rows are a random
     --comb of the the first A_(i-1) elements of X, which should be of length 
     --at least (last A). For the moment we assume that the entries of X are linear,
     --and make a linear matrix
     n=#A;
     S:=ring X;
     x:= p-> X_{0..p-1};
     row:=q->x(A_(q-1))*random(S^{A_(q-1):-1}, S^{n-1:-1});
     m:= row(1);
     for q from 2 to n do m = m||row(q);
     m)
sMatrix(A,X)

m=sMatrix({2,2,2,4},X)
i=minors(3,m)

data= i->(
     print "Gm, An Spr, red num";
     print(whichGm i, analyticSpread i,reductionNumber i))
data i
m=sMatrix({4,4,4,4},X)
test = A->data(minors (#A-1,sMatrix(A,X)))
test {4,4,4,4}     
test(A={2,2,2})
m=sMatrix({2,2,2},X)
i=minors(2,m)
j=minimalReduction i
i^2 == (j*i)
--guess: an spr is the max number of vars in a row. red num is 0 or 1 when entries are linear,
--but larger d when entries are of degree d>1 (entries of deg 3: then a 4x3 gives 4, a 5x4 gives 3.)
m=sMatrix(A,X)
i=minors(4,m)

S=kk[a,b]
Y=gens (ideal vars S)^3
testY=A->data(minors (#A-1,sMatrix(A,Y)))
testY{4,4,4,4,4}
m=catalecticant(4,3,S)
i=minors(3,m)
data i
