--Part I
--Given an I ideal in k[x..,y...], find the largest equivalence
--relation J \subset I. 
--returns an error if the relation does not become transitive after
--at most b "transitivizing" steps. The bound b defaults to 10.
makeEquiv = method()
makeEquiv(Ideal,ZZ) := (I,b) -> makeTransitive (makeSymmetric makeReflexive I, b)
makeEquiv(Ideal) := I-> makeTransitive (makeSymmetric makeReflexive I, 10)

--Assume: there are two sets of variables x_1...x_n, y_1...y_n (names can be different)


interchange = S -> (
     n:= (numgens S)//2;
     map(S,S,{S_n..S_(2*n-1),S_0..S_(n-1)}))

makeSymmetric = I -> I+(interchange ring I)I
makeReflexive = I -> (
     	  S := ring I;
          n := (numgens S)//2;
	  intersect(I,ideal apply (n, i-> S_i-S_(n+i))))

makeTransitive1=J->(
     --doesn't currently work with quotients
     S:=ring J;
     n:=(numgens ring J)//2;
     X:=local X;
     Y:=local Y;
     Z:=local Z;
     T:=kk[X_1..X_n,Y_1..Y_n,Z_1..Z_n];
     XZ:=map(T,S,{X_1..X_n,Z_1..Z_n});
     YZ:=map(T,S,{Y_1..Y_n,Z_1..Z_n});
     JXZ := XZ J;
     JYZ := YZ J;
     trim kernel map(T/(JXZ+JYZ),S,{X_1..X_n,Y_1..Y_n}))
     
t1=makeTransitive1

makeTransitive = method()
makeTransitive(Ideal, ZZ) := (J,b) ->(
     --performs the "transitivizing" step at most b times. 
     --returns an error msg if the result is not transitive.
     J1:=makeTransitive1 J;
     test := isSubset(J,J1);
     if test then return J;
     i:=0;
     while i<b and not test do (
     	  J=J1;
	  J1=makeTransitive1 J;
	  i=i+1;
	  test = isSubset(J,J1)
	  );
     if not test then error("could not make transitive in given number of steps");
     J)

-- Part II
-- Given an ideal I in k[x,y] (two sets of variables, same number)
-- find the polys g(x) of degree at most d such that g(x)-g(y) \in I.

degreepart = method()
degreepart(ZZ,List) := (d,L) -> (
     --forms a matrix whose entries are a basis of 
     --the polynomials that are of degree d and are in the ring 
     --generated by the given list L of polynomials 
     -- or the empty LIST if there are none.
     if #L == 0 then {}
     else (
       A := ring L_0;
       kk:=coefficientRing A;
       z:=local z;
       S := kk[z_1..z_(#L), Degrees=>(L/degree)];
       F := map(A,S,L);
       T := coimage F;
       F(sub(basis(d,T), S))
     ))

///
alg = method()
alg(List) := (L) -> (
     --
     if #L == 0 then {}
     else (
       S := kk[z_1..z_(#L), Degrees=>(L/degree)];
       A := ring L_0;
       F := map(A,S,L);
       ker F)
     )
///

findequiv = (I,d,L,I0,toBx, toBy,toA) -> (
     --used in mapFromEquivalence
     -- I is the ideal in question
     -- d is the degree to search in
     -- L is the k-algebra generating set of all such in lower degree
     M := degreepart(d,L); -- we wish to avoid these
     -- now take a basis of the degree d part of the ideal I0 = I(x,y=0).
     -- and reduce it using M.
     -- This will
     N := compress(super basis(d,I0));
     if #L =!= 0 then (	  
     	  gbM := gb(M, DegreeLimit=>d);
     	  N = compress(super basis(d,I0) % gbM));
     C1 := toBx N - toBy N;
     C2 := gens I;
     Z := syz gb(C1 | C2, Syzygies => true, 
	  SyzygyRows=>numgens source C1, DegreeLimit=>d);
     flatten entries toA gens gb(C1 * Z, DegreeLimit=>d)
     )

mapFromEquivalence = method()
mapFromEquivalence(ZZ, Ideal, Ring) := (d, I, A) -> (
     B := ring I;
     n := numgens A;
     toA = map(A,B,vars A | (vars A - vars A));
     toBx = map(B,A,{B_0..B_(n-1)});
     toBy = map(B,A,{B_n..B_(2*n-1)});
     I0 = trim toA I;
     d0 := first min((flatten entries gens I)/degree);
     L := {};
     for i from d0 to d do (
	  Lnew := findequiv(I,i,L,I0,toBx, toBy,toA);
	  L = L | Lnew;
--uncomment the following line for verbose output.	  
--	  << "found " << #Lnew << " new algebra generators in degree " << i << endl;
	  );
     L
     )
mapFromEquivalence(Ideal, Ring) := (I, A) -> (
     d:=max flatten degrees source gens I;
     mapFromEquivalence(d,I, A))

--Part III: The inverse of part II
equivalenceFromMap=method()
equivalenceFromMap(List,Ring):=(L,B)->(
     if #L==0 then return ideal(0_B);
     A:=ring L_0;
     n := numgens A;
     toBx = map(B,A,{B_0..B_(n-1)});
     toBy = map(B,A,{B_n..B_(2*n-1)});
     L=matrix{L};
     trim ideal(toBx L - toBy L))

--test whether the eqivalence relation derived from an
--ideal I in 2n variables comes from a map
isEquivFromMap = I->(
     B:=ring I;
     X:=local X;
          n:=(numgens B)//2;
     A:=(coefficientRing B)[X_1..X_n];
     K:=makeEquiv I;
     L:=mapFromEquivalence(K,A);
     K1:=equivalenceFromMap(L,ring I);
     val:= isSubset(K,K1);
     if not val then (
	  print"the following ideal leads to an equiv relation not coming from a map";
	  print I;
	  );
     val)

///
restart
load "findequiv.m2"
load "randomIdeal.m2"

kk=ZZ/101
n=2
A = kk[x_1..x_n]
B = kk[x_1..x_n,y_1..y_n]
I = ideal(x_1^2*x_2^3+50*x_1*x_2^4-y_1^2*y_2^3-50*y_1*y_2^4,
     x_2*y_1^2*y_2^3+50*x_2*y_1*y_2^4-y_1^2*y_2^4-50*y_1*y_2^5,
     x_1*y_1^2*y_2^3+50*x_1*y_1*y_2^4-y_1^3*y_2^3-50*y_1^2*y_2^4,x_1*x_2^5-y_1*y_2^5,x_2*y_1*y_2^5-y_1*y_2^6)
--mapFromEquivalence(14,I,A)
time mapFromEquivalence(I,A)
isEquivFromMap I

kk=ZZ/101
n=3
A = kk[x_1..x_n]
B = kk[x_1..x_n,y_1..y_n]
I=randomBinomialIdeal({2,3,3,4,5},B)
-- K=makeEquiv I
--L=mapFromEquivalence(K,A)
--K1=equivalenceFromMap(L,B)
--K==K1
isEquivFromMap I
///

end 

-------------Test a bunch of random examples:
restart
load "findequiv.m2"
load "randomIdeal.m2"

kk=ZZ/101
n=2
B = kk[x_1..x_n,y_1..y_n]
time for p from 1 to 100 do(
     I = (ideal vars B)^[4]+ 
     randomMonomialIdeal({3,4,5,5},B)+
     randomBinomialIdeal({3,3},B)+
     randomIdeal(vars B,{2});
     isEquivFromMap I)

