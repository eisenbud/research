--Given an I ideal in k[x..,y...], find the largest equivalence
--relation J \subset I.
--Assume: there are two sets of variables x_1...x_n, y_1...y_n (names can be different)
interchange = S -> (
     n:= (numgens S)//2;
     map(S,S,{S_n..S_(2*n-1),S_0..S_(n-1)}))

symmetrize = I -> I+(interchange ring I)I
reflexivise = I -> (
     	  S := ring I;
          n := (numgens S)//2;
	  intersect(I,ideal apply (n, i-> S_i-S_(n+i))))

transitivity1=J->(
     --doesn't currently work with quotients
     S:=ring J;
     n:=(numgens ring J)//2;
     X:=local X;
     Y:=local Y;
     Z:=local Z;
     T:=kk[X_1..X_n,Y_1..Y_n,Z_1..Z_n];
     XZ:=map(T,S,{X_1..X_n,Z_1..Z_n});
     YZ:=map(T,S,{Y_1..Y_n,Z_1..Z_n});
     JXZ := XZ J;
     JYZ := YZ J;
     ideal mingens kernel map(T/(JXZ+JYZ),S,{X_1..X_n,Y_1..Y_n}))
     
t1=transitivity1

transitivity = (J,b) ->(
     --loop at most b times
     J1:=transitivity1 J;
     i:=0;
     while i<b and not isSubset(J, J1) do (
     	  J=J1;
	  J1=transitivity1 J;
	  i=i+1);
     J)

-- Given an ideal I in k[x,y] (two sets of variables, same number)
-- find the polys g(x) of degree d, such that g(x)-g(y) \in I.
-- Also given: a generating set of all such (generating in the algebra sense)
-- of degree <= d-1.

degreepart = method()
degreepart(ZZ,List) := (d,L) -> (
     --forms a matrix whose entries are a basis of 
     --the polynomials that are of degree d and are in the ring 
     --generated by the given list L of polynomials 
     -- or the empty LIST if there are none.
     if #L == 0 then {}
     else (
       A := ring L_0;
       kk:=coefficientRing A;
       z:=local z;
       S := kk[z_1..z_(#L), Degrees=>(L/degree)];
       F := map(A,S,L);
       T := coimage F;
       F(sub(basis(d,T), S))
     ))

///
alg = method()
alg(List) := (L) -> (
     --
     if #L == 0 then {}
     else (
       S := kk[z_1..z_(#L), Degrees=>(L/degree)];
       A := ring L_0;
       F := map(A,S,L);
       ker F)
     )
///

findequiv = (I,d,L,I0,toBx, toBy,toA) -> (
     --used in mapFromEquivalence
     -- I is the ideal in question
     -- d is the degree to search in
     -- L is the k-algebra generating set of all such in lower degree
     M := degreepart(d,L); -- we wish to avoid these
     -- now take a basis of the degree d part of the ideal I0 = I(x,y=0).
     -- and reduce it using M.
     -- This will
     N := compress(super basis(d,I0));
     if #L =!= 0 then (	  
     	  gbM := gb(M, DegreeLimit=>d);
     	  N = compress(super basis(d,I0) % gbM));
     C1 := toBx N - toBy N;
     C2 := gens I;
     Z := syz gb(C1 | C2, Syzygies => true, 
	  SyzygyRows=>numgens source C1, DegreeLimit=>d);
     flatten entries toA gens gb(C1 * Z, DegreeLimit=>d)
     )

mapFromEquivalence = method()
mapFromEquivalence(ZZ, Ideal, Ring) := (d, I, A) -> (
     B := ring I;
     n := numgens A;
     toA = map(A,B,vars A | (vars A - vars A));
     toBx = map(B,A,{B_0..B_(n-1)});
     toBy = map(B,A,{B_n..B_(2*n-1)});
     I0 = trim toA I;
     d0 := first min((flatten entries gens I)/degree);
     L := {};
     for i from d0 to d do (
	  Lnew := findequiv(I,i,L,I0,toBx, toBy,toA);
	  L = L | Lnew;
	  << "found " << #Lnew << " new algebra generators in degree " << i << endl;
	  );
     L
     )
mapFromEquivalence(Ideal, Ring) := (I, A) -> (
     d:=max flatten degrees source gens I;
     mapFromEquivalence(d,I, A))
equivalenceFromMap=method()
equivalenceFromMap(List,Ring):=(L,B)->(
     if #L==0 then return ideal(0_B);
     A:=ring L_0;
     n := numgens A;
     toBx = map(B,A,{B_0..B_(n-1)});
     toBy = map(B,A,{B_n..B_(2*n-1)});
     L=matrix{L};
     ideal(toBx L - toBy L))

end
restart
load "findequiv.m2"

n=2
A = kk[x_1..x_n]
B = kk[x_1..x_n,y_1..y_n]
toA = map(A,B,vars A | (vars A - vars A))
toBx = map(B,A,{x_1..x_n})
toBy = map(B,A,{y_1..y_n})

use A
I0 = ideal(x_1^2, x_1^3)
I = ideal gens gb ideal(toBx gens I0 - toBy gens I0)
findequiv(I,3,{x_1^2})


L = {x_1^2, x_2^3, x_1*x_2}
degreepart(4,L)

restart
load "findequiv.m2"
load "randomIdeal.m2"

kk=ZZ/101
n=2
A = kk[x_1..x_n]
B = kk[x_1..x_n,y_1..y_n]
I = ideal(x_1^2*x_2^3+50*x_1*x_2^4-y_1^2*y_2^3-50*y_1*y_2^4,
     x_2*y_1^2*y_2^3+50*x_2*y_1*y_2^4-y_1^2*y_2^4-50*y_1*y_2^5,
     x_1*y_1^2*y_2^3+50*x_1*y_1*y_2^4-y_1^3*y_2^3-50*y_1^2*y_2^4,x_1*x_2^5-y_1*y_2^5,x_2*y_1*y_2^5-y_1*y_2^6)
--mapFromEquivalence(14,I,A)
mapFromEquivalence(I,A)

kk=ZZ/101
n=2
A = kk[x_1..x_n]
B = kk[x_1..x_n,y_1..y_n]
I=randomBinomialIdeal({2,3,3,4,5},B)
J=reflexivise symmetrize I
K=transitivity (J,10)
L=mapFromEquivalence(K,A)
K1=equivalenceFromMap(L,B)
K==K1

d=5
I=ideal mingens ideal(apply(d, j->x_1*x_2^(j+1)-y_1*y_2^(j+1)))
K=transitivity(I,10)
L=mapFromEquivalence(7,K,A)
R=equivalenceFromMap(L,B)
mingens oo
betti ideal oo
betti K
I0 = trim toA I
betti I
I_0
L = {I0_0}
L6 = findequiv(I,6,L)
L7 = findequiv(I,7,L|L6)
allL = matrix{L|L6|L7}
J = ideal(toBx allL - toBy allL)

L8 = findequiv(I,8,L|L6|L7)
L9 = findequiv(I,9,L|L6|L7|L8)

betti I
