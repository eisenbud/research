--path = append(path,"/a/young/young1/de/macaulay")
path = append(path,"/home/de/m2")
load "monom.m2"

--rewrite of ^[]

Ideal ^ Array := (I,a) -> (
     if #a =!= 1 then error "expected an integer";
     if not instance(a#0,ZZ) then error "expected an integer";
     r := a#0;
     ideal(apply(numgens I, i -> I_i^r)))


Matrix ^ Array := (m,a) -> (
     if #a =!= 1 then error "expected an integer";
     if not instance(a#0,ZZ) then error "expected an integer";
     r := a#0;
     dm:= d*flatten degrees target m;
     em:= d*flatten degrees source m;
     map((ring M)^(-dm),(ring m)^(-em),(u,v)->(m_(u,v)^d)))


document{quote frobenius, 
TT "M=Ideal or Matrix^[d=ZZ]"," -- Raising
an Ideal or Matrix M to a power consisting of an array of one integer
d returns the d-th frobenius power of M.  In case M is a Matrix, the
row and column degrees of M are all multiplied by d."}

TEST///
kk=ZZ/32003
S=kk[a,b,c,d]
m=matrix{{a,b},{c,d}}
m^[2]
(ideal vars S)^[2]
///

randomIdeal=(I,L)->(
ideal((gens I)*random(source gens I, (ring I)^(-L))))

document{quote randomIdeal,
TT "randomIdeal(I=Ideal,L=List of ZZ)","--
Returns an Ideal generated by random elements of I
with degrees specified by the elements of L."}

show = method()
--methods for Matrix, Ideal, Module, List
show(Matrix):= (M)-> (
  if ((rank source gens M <10) and (rank target gens M <10)) then print M;
     betti M)

show(Ideal) := (I) -> (
if rank source gens I < 5 then print I else
if rank source gens I < 30 then 
                      print transpose gens I;
    betti gens I)

show(Module) := (M) -> (
    if isFreeModule M then (
       print "Free module";
       degrees M)            else
         (N:= prune M;
         if (rank source gens M <10 and 
             rank target gens N <10)   then print N;
     betti gens N)
           )

show(List) := (L) -> scan(L, i->print i)

document{quote show,
TT"--show","displays an Ideal, Module, Matrix, or List",PARA,
"Applied to an object of type Ideal, Module, Matrix, or List,
show displays useful information about the object.
The format and content depend on the size of the object."}

-----------------------------Some special purpose functions

catalecticant = (R,v,m,n) -> 
                 map(R^m,n,(i,j)-> R_(i+j+v))

document{quote catalecticant,
TT"--catalecticant(R=Ring,i=ZZ,j=ZZ,v=ZZ)","Returns
a Matrix whose (i,j) entry is the i+j+v variable of R."}

-----------------------------
MultiDegs = n-> entries (transpose map(ZZ^1,ZZ^n,matrix{{n:1}}) |id_(ZZ^n))

document{quote MultiDegs,
     TT"--MultiDegs(ZZ)","returns a matrix over ZZ suitable for 
     defining the ZZ^n-grading on a polynomial ring in n variables,
     via the option Degrees. Usage:
     R = kk[vars(0..n-1), Degrees=>MultiDegs n]."}

----------------------------
HF = (degs, M) -> toList (
     apply(degs,i->hilbertFunction(i,M)))
document{quote HF,
     TT"--HF(Sequence or List,Module)","using hilbertFunction(ZZ,Module),
     HF returns a Sequence or List
     of the values of the Hilbert function of the Module
     at the integer arguments specified by the Sequence or List."}

----------------------------
--for some reason we also did it with small letters
hf=(range, m)->(
       apply(range,i->hilbertFunction(i, m)))
document{quote hf,
     TT"--hf(Sequence or List,Module)","using hilbertFunction(ZZ,Module),
     hf returns a Sequence or List
     of the values of the Hilbert function of the Module
     at the integer arguments specified by the Sequence or List."}

---------------------------
symExt= (m,R) ->(
--this function converts between the a linear presentation map
--of a module over a symmetric algebra and the first map
--in the corresponding complex of modules over the exterior
--algebra, and vice-versa. The matrix m is the given
--** linear **
-- presentation map, and R is the target ring. 
--the script returns a linear map over R. If 
--coker m has linear resolution (regularity 0)
--then the resolution of coker p will be linear, 
--and will be the complex corresponding to coker m.
     ev := map(R,ring m,vars R);
     mt := transpose jacobian m;
     jn := gens kernel mt;
     q  := vars(ring m)**id_(target m);
     n  := ev(q*jn);
     map(R^(rank target n),R^{rank source n:-1},n))
--The line
--map(R^(rank target n),R^(apply(rank source n, i->-1)),n))
--is needed to correct funny degrees introduced in q*jn. FIX
--

ecoh=(m,R,terms)->(
     M   := coker m;
     reg := regularity M;
     mt  := presentation truncate(reg,M);
     n   := symExt(mt,R);
--     n   =  map(R^(apply(rank target n,i->-reg)),
--	    R^(apply(rank source n, i->-reg-1)),
--	    n);
     res(coker transpose n, LengthLimit=>terms)
     )
     
---------------------

linearPart = m->(
-- Suppresses all terms of degree >1. Leaves degrees of source and
-- target alone.
     R := ring m;
     n := rank source vars R;
     R1:= (coefficientRing R)[vars(0..n)];
     M =  substitute(m, (R1_0)*((vars R1)_{1..n}));
     N := M//(R1_0);
     N = substitute(N, matrix{{0_R}}|(vars R));
     sourcedegs := flatten degrees source m;
     targetdegs := flatten degrees target m;
     map(R^(-targetdegs),R^(-sourcedegs),N))
-- the last lines are necessary because in 
-- the degrees
-- are set wrong otherwise


-- This version changes degrees of source and target to 1, 0
linearPart1 = m->(
     n:=linearPart m;
     map(R^{rank target n}, R^{(rank source n):-1},n) 
     )
----------------
--for arrangements:
--Construction of Orlik-Solomon algebras
--The idea is to code the dependent sets (circuits) as 
--monomials, then apply an operator that makes each monomial
--into the corresponding Orlik-Solomon relation.

--The following takes a monomial in the exterior alg and manufactures
--an Orlik-Solomon relation from it (the alt sum of the derivatives
--with respect to the variables in the monomial)
orlikSolomon1 = n-> (
     d:=(degree n)_0;
     (compress diff(vars R, n))*
               (transpose map(R^1,R^d,{{d:1}}))
     )

--now the same thing for a whole ideal:
orlikSolomon = i->(
     p:=rank source gens i;
     j:=ideal(orlikSolomon1(i_0));
     scan(p-1,t->(j=j+ideal(orlikSolomon1(i_(t+1)))));
     j)
---------------------
--If M is a module over the polynomial ring S, 
--E is the corresponding exterior algebra, e\in E_1,
--let \kappa(e) be the residue field of Proj S at the point e.
--The following returns Tor(M,\kappa(e)), regarded as an E-module.
torModule=(M,e,E)->(
     reg := regularity M;
     mt  := presentation truncate(reg,M);
     n   := symExt(mt,E);
     F   := res coker n;
     N   := kernel transpose F.dd_1;
     mape:= map(E^1,E^{-1},matrix{{e}});
     prune (kernel ((E^{1}**mape)**N)/(image (mape**N))))

--This gives the free resolution of the dual module (the dual
--of the injective resolution of Tor)
resDualTor=(M,e,E)->(
     N := torModule(M,e,E);
     Nd:= Hom(N,E);
     res Nd)

--The following returns the submodule generated by the degree d
--generators of the module A
gensOfDeg=(A,d)->(
     F := target presentation A;
     L := flatten degrees F;
     L1:= toList select(0..10,i->(L_i)==d);
     prune (image F_L1/(image presentation A)))

--The following returns the dual of the d-th linear strand of the 
--Tor(M,\kappa(e)) as a module over E
strand=(M,e,E,d)->(
     T := torModule(M,e,E);
     T1:= Hom(T,E);
     gensOfDeg(T1,d))
----------
kk = ZZ/32003;
R = kk[a..e];
print "R = kk[a..e]"












