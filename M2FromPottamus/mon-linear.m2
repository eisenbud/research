-- Search for ideals in 4 variables which do not satisfy 
-- that (1 step linear)(1 step linear) != 2 step linear
-- and
--      (1 step linear)(2 step linear) != power of max ideal

randomMonomials = (Blist, nelems) -> (
     -- Input: Blist: a list of lists of monomials
     --        nelems: a list, of same size as Blist, of integers
     -- Output: An ideal, minimally generated by a random choice of nlist#i monomials
     --        from Blist#i.
     -- Assumption: (1) each list in Blist consists of monomials of the same degree
     --             (2) the degrees are increasing.
     ideal flatten apply(#nelems, d -> (
	       n := #Blist#d;
	       apply(nelems#d, i -> Blist#d#(random n))))
     )

randomBinomials = (Blist, nelems) -> (
     -- Input: Blist: a list of lists of monomials
     --        nelems: a list, of same size as Blist, of integers
     -- Output: An ideal, minimally generated by a random choice of nlist#i binomials
     --        from Blist#i.
     -- Assumption: (1) each list in Blist consists of monomials of the same degree
     --             (2) the degrees are increasing.
     ideal flatten apply(#nelems, d -> (
	       n := #Blist#d;
	       apply(nelems#d, i -> Blist#d#(random n) - Blist#d#(random n))))
     )

linearity = (I) -> (
     C := res I;
     -- check that the degrees of the generators are all the same
     d1 := first min degrees C_1;
     d2 := first max degrees C_1;
     if d1 =!= d2 then return 0;
     for j from 2 to length C do (
	  e := first max degrees C_j;
	  if e > d1 + j - 1 then return j-2;
	  );
     return length C - 1;
     )

makeLinear = (I) -> (
     C := res I;	       
     truncate(first max degrees C_2 - 1, I)
     )

tryit = (mont, i,j) -> (
     J = mont#i * mont#j;
     --<< "linearities = " << linearity mont#i << " and " << linearity mont#j << endl;
     --betti res J
     (linearity mont#i, linearity mont#j, linearity J)
     )

twist = (i,I) -> (
     C := res(I, LengthLimit => i+2);
     max apply(degrees C_(i+1), first))

tryit = (mont, i,j) -> (
     J = mont#i * mont#j;
     (twist(1,mont_i), twist(1,mont_j), twist(2,J))
     )

doit = (ntries,mont) -> scan(ntries, j -> (
	  x = (random(#mont), random(#mont));
	  << "tryit" << x << " gives " << flush << tryit(mont, x#0, x#1) << endl;
	  ))

doitsame = (ntries,mont) -> (scan(ntries, j -> (
	  if j % 50 == 0 then ( << "." << flush;);
	  i := random(#mont);
	  x = (i,i);
	  (a,b,c) := tryit(mont,x#0,x#1);
	  if a+b < c then (
	       print toString mont#i;
	       << "tryit" << x << " gives " << (a,b,c) << endl;
	       );
	  ));
	  print "done with all examples";
	  )

doitsame2 = (mont) -> (scan(#mont, j -> (
	  if j % 50 == 0 then ( << "." << flush;);
	  x = (j,j);
	  I := mont#j;
	  I2 := I^2;
	  
	  (a,b,c) := tryit(mont,x#0,x#1);
	  if a+b < c then (
	       print toString mont#i;
	       << "tryit" << x << " gives " << (a,b,c) << endl;
	       );
	  ));
	  print "done with all examples";
	  )
	  
end

restart
load "mon-linear.m2"
R = ZZ/101[a..e]
P = ideal apply(gens R, x -> x^3)
B4 = flatten entries basis(3,coker gens P)
B5 = flatten entries basis(4,coker gens P)
getideal = () -> (
     I := ideal mingens (P + randomMonomials({B4,B5},{4,0}));
     if numgens I =!= numgens P + 4 then null
     else I)
time apply(10, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
mont = apply(monids, I -> makeLinear I);

doit(50,mont)


---------------------------
-- 6 variables -- cubics --
---------------------------
R = ZZ/101[a..f]
P = ideal apply(gens R, x -> x^3)
B4 = flatten entries basis(3,coker gens P)
B5 = flatten entries basis(4,coker gens P)
getideal = () -> (
     I := ideal mingens (P + randomMonomials({B4,B5},{4,0}));
     if numgens I =!= numgens P + 4 then null
     else I)
time apply(1000, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
mont = apply(monids, I -> makeLinear I);

doit(50,mont)

-- try resoutions
(i,j) = (10,24)
(i,j) = (7,41)
betti res monids_i
first max degrees (res monids_i)_2
betti res monids_j
first max degrees (res monids_j)_2
J = monids_i * monids_j;
betti res J
tryit(mont,i,j)
J1 = truncate(9,J);
------------------------------------
-- 5 variables -- quartic binomials --
------------------------------------
R = ZZ/101[a..e]
P = ideal apply(gens R, x -> x^4)
B4 = flatten entries basis(4,coker gens P)
B5 = flatten entries basis(5,coker gens P)
getideal = () -> (
     I := ideal mingens (P + randomBinomials({B4,B4},{4,0}));
     if numgens I =!= numgens P + 4 then null
     else I)
time apply(200, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
mont = apply(monids, I -> makeLinear I);
mont/linearity
doit(50,mont)
--tryit(116, 116) gives (1, 1, 4)
--tryit(7, 164) gives (1, 1, 4)
--tryit(82, 44) gives (1, 1, 4)
--tryit(3, 158) gives (1, 1, 4)
--tryit(109, 47) gives (1, 1, 4)

------------------------------------
-- 6 variables -- quartic binomials --
------------------------------------
R = ZZ/101[a..f]
P = ideal apply(gens R, x -> x^4)
B4 = flatten entries basis(4,coker gens P)
B5 = flatten entries basis(5,coker gens P)
getideal = () -> (
     I := ideal mingens (P + randomBinomials({B4,B4},{4,0}));
     if numgens I =!= numgens P + 4 then null
     else I)
time apply(200, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
mont = apply(monids, I -> makeLinear I);
mont/linearity
doit(50,mont)
tryit(mont,4,4)

------------------------------------
-- 6 variables -- quartic binomials --
------------------------------------
restart
load "mon-linear.m2"
R = ZZ/101[a..g]
P = ideal apply(gens R, x -> x^3)
B4 = flatten entries basis(3,coker gens P)
getideal = () -> (
     I := ideal mingens (P + randomBinomials({B4,B4},{2,0}));
     if numgens I =!= numgens P + 2 then null
     else I)
time apply(200, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids

doitsame(100,monids)
tryit(monids,0,0)

p = ideal flatten entries gens monids_0
twist(1,monids_0)
twist(2,monids_0)
twist(3,monids_0)
twist(4,monids_0)
twist(5,monids_0)
twist(6,monids_0)

doit(100,monids)

betti res monids_132
betti res monids_63
J = monids_132 * monids_63;
gbTrace 1
betti res J
mont = apply(monids, I -> makeLinear I);
mont/linearity
doit(50,mont)
tryit(mont,4,4)

str = toString monids_148
-- THE EXAMPLE!!
--ideal(g^3,f^3,c*e*f-f*g^2,e^3,d^3,a*d^2-d^2*e,c^3,b^3,a^3)

p = monids_148
betti res p
p2 = p^2;
betti res p2
m5 = truncate(5,p);
betti res m5
m52 = m5^2;
betti res(m52, LengthLimit=>4, DegreeLimit=>14)
degree p
betti res p
p3 = p^3;
gbTrace 1
betti res p3

p
betti res p
betti res m5

A = ZZ/101[a,b,c,d,e,f,g]
p = ideal(g^3,f^3,c*e*f-f*g^2,e^3,d^3,a*d^2-d^2*e,c^3,a^3)
betti res p
twist(1,p)
p2 = p^2;
twist(2,p2)
betti res p2

------------------------------------
-- 6 variables -- quadrics binomials --
------------------------------------
restart
load "mon-linear.m2"
R = ZZ/13[a..f]
P = ideal apply(gens R, x -> x^2)
B4 = flatten entries basis(2,coker gens P)
getideal = () -> (
     ngens := 3;
     I := ideal mingens (P + randomBinomials({B4,B4},{ngens,0}));
     if numgens I =!= numgens P + ngens then null
     else I)
time apply(200, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids

doitsame(100,monids)
tryit(monids,0,0)

p = ideal flatten entries gens monids_0
twist(1,monids_0)
twist(2,monids_0)
twist(3,monids_0)
twist(4,monids_0)
twist(5,monids_0)
twist(6,monids_0)

doit(100,monids)

------------------------------------
-- 6 variables -- quadrics binomials --
------------------------------------
restart
load "mon-linear.m2"
R = ZZ/101[a..f]
P = ideal apply(gens R, x -> x^3)
B4 = flatten entries basis(3,coker gens P)
getideal = () -> (
     ngens := 4;
     I := (P + randomMonomials({B4,B4},{ngens,0}));
     --if numgens I =!= numgens P + ngens then null
     --else I)
     I)

time apply(2000, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
doitsame(1000,monids)

p = ideal flatten entries gens monids_0
twist(1,monids_0)
twist(2,monids_0)
twist(3,monids_0)
twist(4,monids_0)
twist(5,monids_0)
twist(6,monids_0)

doit(100,monids)

p = ideal(f^3,e^3,d^3,b*c*d-c*d*e,c^3,b^3,a^2*b-a^2*c,a^3)
betti res p
betti res (p^2)
p5 = truncate(5,p);
betti res p5
m5 = p5^2;
betti res m5

p = ideal(f^3,e^3,d^3,b*c*d-c*d*e,c^3,b^3,a^2*b-a^2*c,a^3,g^3,h^3)
betti res p
betti res (p^2)
twist(1,p)
twist(2,p^2)
p5 = truncate(5,p);
betti res p5
m5 = p5^2;
gbTrace 1
betti res(m5, LengthLimit => 4, DegreeLimit => 14)


p = ideal(a^4,b^4,c^4,d^4,e^4,a*d^2*(b-c),a*b*c*(c-d))
betti res p
twist(1,p)
p2 = p^2;
twist(2,p2)
betti res p2

p = ideal(f^2,e^3,d^3,b*c*d-c*d*e,c^3,b^3,a^2*b-a^2*c,a^3)

prune(p/p^2)
betti res p
betti res (p^2)
p5 = truncate(5,p);
betti res p5
m5 = p5^2;
betti res m5

load "mon-linear.m2"
R = ZZ/101[a,b,c]
P = ideal apply(gens R, x -> x^3)
B4 = flatten entries basis(3,coker gens P)
getideal = () -> (
     ngens := 4;
     I := (P + randomMonomials({B4,B4},{ngens,0}));
     I)

time apply(2000, i -> getideal());
monids = select(oo, a -> a =!= null);
#monids
doitsame(1000,monids)

p = ideal apply(gens R, x -> x^3) + ideal(random)
betti res p 
betti res p^2
twist(1,p)
twist(2,p^2)

-- Not a counterexample

