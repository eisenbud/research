--programs to form a random ideal of one sort or another.
--S is a ring, d a pos int, L a list of pos ints,
--randomMonomial(d,S)
--randomMonomialIdeal(L,S)
--randomBinomialIdeal(L,S)
--regSeq(L,S) -- for the ideal generated by powers of the variables.

--CAVEAT
--might want to make a routine that gives a reliable number of independent random monomials

randomMonomial = (d,S)->(
     m := basis(d,S);
     m_(0,random rank source m))

randomMonomialIdeal=(L,S)->(
     --L=list of degrees of the generators
     ideal apply(L, d -> randomMonomial(d,S))
     )

randomBinomialIdeal=(L,S)->(
     --L=list of degrees of the generators
     ideal apply(L, d->randomMonomial(d,S)-randomMonomial(d,S))
     )

randomSparseIdeal = (B,r,n) -> (
     -- B is a list of monomials
     -- r is the size of each poly
     -- n is the number of polys
     -- returns an ideal
     S := ring B#0;
     ideal apply(n, j -> 
       sum apply(r, i -> random coefficientRing S * B#(random(#B))))
     )

regSeq=(L,S)->(
     --forms an ideal generated by powers of the variables.
     --L=list of NN. uses the initial subsequence of L as degrees of variables
     ideal for m to min(#L,rank source vars S)-1 list S_m^(L_m))

randomIdeal = (B, L) -> (
     -- B is a matrix of monomials
     -- L is a list of degrees
     ideal(B * random(source B, (ring B)^(-L)))
     )

looper = (rep,bound, L1, L2) -> (
     for i from 1 to rep do (
	  if i % 1000 == 0 then << "." << flush;
	  J := randomMonomialIdeal(L1,S) + randomBinomialIdeal(L2,S);
	  m := regularity coker gens J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )

looper1 = (rep,bound) -> (
     for i from 1 to rep do (
	  J := randomIdeal(B,L);
	  m := regularity coker gens J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )

looper3 = (rep,bound,B,r,n) -> (
     -- r is the number of monomials per poly
     -- n is the number of polys
     for i from 1 to rep do (
	  J := randomSparseIdeal(B,r,n);
	  m := regularity coker gens J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )
end

load "randomIdeal.m2"

kk=ZZ/101
S=kk[a,b,c]
L={2,4,5}
L1={2,4}
L2={2,4,5,6}
regSeq(L,S)
regSeq(L1,S)
regSeq(L2,S)

randomBinomialIdeal(L,S)
tally apply(100, i->randomMonomial(4,S))--

load "bettibounds.m2"
S=kk[a,b,c,d]
L={4,4,4,4}
for i from 1 to 10 do print  betti res (
     regSeq({4,4,4,4},S)+randomMonomialIdeal(toList(35:4),S))
toList (5:4)


S=kk[vars(1..7)]
vars S
time res randomMonomialIdeal(toList(35:7),S)
--NOTE: making it of type monomialIdeal doesn't help at all.

------- Banff October 15, 2006 ---------------
restart
load "randomIdeal.m2"

kk=ZZ/5
S=kk[a,b,c]
L={4,4,4}
B = matrix"ab,ac,bc"
time looper(30000,8)

kk=ZZ/2
S=kk[a,b,c,d]
I = ideal"a4,b4,c3a-d3b"
betti res I
regularity I
L={4,4,4}
time looper(3,8,{4},{4,4})
time looper(30000,10,{4,4},{4})
betti res ideal (a*b^3+b^4,b*c^2*d+c^2*d^2,b*c^3+a^3*d)


kk=ZZ/5
S=kk[a,b,c,d]
B = flatten entries gens(ideal basis(2,S) * ideal"a3,b3,c3,d3")
randomSparseIdeal(B,3,4)
looper3(10000,18,B,3,3)
