--programs to form a random ideal of one sort or another.
--S is a ring, d a pos int, L a list of pos ints,
--randomMonomial(d,S)
--randomMonomialIdeal(L,S)
--randomBinomialIdeal(L,S)
--regSeq(L,S) -- for the ideal generated by powers of the variables.

--CAVEAT
--might want to make a routine that gives a reliable number of independent random monomials

randomMonomial = (d,S)->(
     m := basis(d,S);
     m_(0,random rank source m))

randomMonomialIdeal=(L,S)->(
     --L=list of degrees of the generators
     ideal apply(L, d -> randomMonomial(d,S))
     )

randomBinomialIdeal=(L,S)->(
     --L=list of degrees of the generators
     ideal apply(L, d->randomMonomial(d,S)-randomMonomial(d,S))
     )

randomSparseIdeal = (B,r,n) -> (
     -- B is a list of monomials
     -- r is the size of each poly
     -- n is the number of polys
     -- returns an ideal
     S := ring B#0;
     ideal apply(n, j -> 
       sum apply(r, i -> random coefficientRing S * B#(random(#B))))
     )

regSeq=(L,S)->(
     --forms an ideal generated by powers of the variables.
     --L=list of NN. uses the initial subsequence of L as powers
     ideal for m to min(#L,rank source vars S)-1 list S_m^(L_m))

randomIdeal = (B, L) -> (
     -- B is a matrix of monomials
     -- L is a list of degrees
     ideal(B * random(source B, (ring B)^(-L)))
     )

looper = (rep,bound, L1, L2) -> (
     for i from 1 to rep do (
	  if i % 1000 == 0 then << "." << flush;
	  J := randomMonomialIdeal(L1,S) + randomBinomialIdeal(L2,S);
	  m := regularity coker gens J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )

looper1 = (rep,bound) -> (
     for i from 1 to rep do (
	  J := randomIdeal(B,L);
	  m := regularity coker gens J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )

looper3 = (rep,bound,B,r,n) -> (
     -- r is the number of monomials per poly
     -- n is the number of polys
     for i from 1 to rep do (
	  if i % 1000 == 0 then << "." << flush;
	  J := randomSparseIdeal(B,r,n);
	  m := regularity J;
	  if m >= bound
	  then << "reg " << m << " " << toString J << endl;
	  )
     )

loopprojdim = (rep,bound,B,r,n) -> (
     -- r is the number of monomials per poly
     -- n is the number of polys
     for i from 1 to rep do (
	  if i % 1000 == 0 then << "." << flush;
	  J := randomSparseIdeal(B,r,n);
	  m := pdim coker gens J;
	  if m >= bound
	  then << "pdim " << m << " " << toString J << endl;
	  )
     )

loopprojdim2 = (rep,bound,B,r,n) -> (
     H = new MutableHashTable;
     -- r is the number of monomials per poly
     -- n is the number of polys
     for i from 1 to rep do (
	  if i % 1000 == 0 then << "." << flush;
	  J := randomSparseIdeal(B,r,n);
	  b := betti res J;
	  m := pdim coker gens J;
	  if H#?(m,b) then H#(m,b)=H#(m,b)+1 else H#(m,b)=1;
	  if m >= bound
	  then << "pdim " << m << " " << toString J << endl;
	  )
     )
end

restart
load "randomIdeal.m2"

kk=ZZ/101
S=kk[a,b,c]
L={2,4,5}
L1={2,4}
L2={2,4,5,6}
regSeq(L,S)
regSeq(L1,S)
regSeq(L2,S)

randomMonomial(4,S)
randomBinomialIdeal(L,S)
randomBinomialIdeal(toList(4:3),S)
tally apply(100, i->randomMonomial(4,S))--

load "bettibounds.m2"
S=kk[a,b,c,d]
L={4,4,4,4}
for i from 1 to 10 do print  betti res (
     regSeq({4,4,4,4},S)+randomMonomialIdeal(toList(35:4),S))
toList (5:4)


S=kk[vars(1..7)]
vars S
time res randomMonomialIdeal(toList(35:7),S)
--NOTE: making it of type monomialIdeal doesn't help at all.

------- Banff October 15, 2006 ---------------
restart
load "randomIdeal1.m2"

kk=ZZ/5
S=kk[a,b,c]
L={4,4,4}
B = matrix"ab,ac,bc"
time looper(30000,8)

kk=ZZ/2
S=kk[a,b,c,d]
I = ideal"a4,b4,c3a-d3b"
betti res I
L={4,4,4}
time looper(30000,10,{4},{4,4})
time looper(30000,10,{4,4},{4})
betti res ideal(c^4,b^4,a^3*c+b*d^3) -- reg 14


restart
load "randomIdeal.m2"

kk=ZZ/2
S=kk[a,b,c,d]
B = flatten entries gens(ideal basis(2,S) * ideal"a3,b3,c3,d3")
randomSparseIdeal(B,3,4)
scan(13, i -> random 1000)
looper3(100000,18,B,3,3)
looper3(100000,18,B,2,4)

ideal (a^5,b*c^4+a^2*d^3+a*d^4,b^5)
ideal (a^5,a*b^4+b^5,a*c^4+b*d^4)
-- ideal(a^5,b^5,c^4*a+d^4*b) -- Giulio's example

restart
load "randomIdeal.m2"
kk = ZZ/3
S=kk[vars(0..10)]
J=ideal(a)+ideal(random(S^1, S^{-2}))
B = flatten entries super basis(3,J);
--loopprojdim(700000,5,B,3,3)
--loopprojdim2(10000,5,B,3,3)
time loopprojdim2(10000,5,B,3,3)
H
peek H
H
