incr-set prlevel 1
if #0=6 START
incr-set prlevel -1
;;; Usage:
;;; 	<rees-sym i rees symalg H h hrem
;;;
;;; Given an ideal i generated by forms all of a single degree
;;; in a poly ring r (with variables of degree 1), 
;;; the script computes the ideal rees of the Rees algebra,
;;; the ideal symalg of the symmetric algebra, in a new
;;; polynomial ring T in variables x[i] corresponding
;;; to the variables of the base ring of i and 
;;; y[j] corresponding to the generators of i.  It tests
;;; whether the ideal has linear type on the punctured 
;;; spectrum (that is, whether rees/symalg is annihilated by a 
;;; power of the original variables), and outputs the 
;;; numerator H of the 2-variable hilbert series of rees/symalg,
;;; in variables x corresponding to the vars of the base ring
;;; of i, and y corresponding to the generators of i, and 
;;; the result of dividing (with remainder) H by (1-x)^d.
;;; (The remainder is 0 iff the ideal i is of linear type
;;; on the punctured spectrum).
;;;
incr-set prlevel 1
jump END
;;; Parameters: i an ideal
;;;
;;; Output values:rees symalg  ideals in a new poly ring T
;;;         H h hrem polynomials in 2 vars x,y
;;;
;;; (discussion)
;;;
;;; Caveats:
;;;
; created October 28, 1995 DE+BU
START:
nvars #1 @d

ncols #1 @n
copy #1 @i
res @i @ii

;bring #1 into a ring whose variable names are x
;(NOTE: <blowup i T J
;depends on knowing that the first
;variables of T have the same names as those in i)

<copyring x @r
ev @r #1 @i
ev @r @ii.2 @syz


;pass to ring with @d "old" and @n "new" variables
<ring @d+@n x[1]-x[@d]y[1]-y[@n] @T
submat @T @xvars
;
1..@d
submat @T @yvars
;
@d+1..@d+@n

;compute the ideal of the symmetric algebra
ev @xvars @syz @syz
mult @yvars @syz #3
std #3 #3
betti #3

;compute the ideal of the Rees algebra
<blowup @i @T #2
std #2 #2
betti #2

;get the generating poly in variables x[1],y[1]
<ideal @ones 1 1
power @ones @d-1 @xseg
power @ones @n-1 @yseg
poly @X x[1]
poly @Y y[1]
mult @X @xseg @spec
mult @Y @yseg @yseg
concat @spec @yseg


hilb_numer #2 @spec @Hrees
hilb_numer #3 @spec @Hsymalg
subtract @Hsymalg @Hrees @H

<ring 3 xyt @pars
<zeromat 1 @d-1 @zd
<zeromat 1 @n-1 @zn
<ideal @x x
<ideal @y y
concat @x @zd @y @zn
type @x

ev @x @H @h

;divide h by x-1^d
homog @h t @ht
type @ht
<ideal @divisor 1-x
homog @divisor t @divisor
power @divisor @d @divisor
lift_std @divisor @divisor

reduce @divisor @ht @htrem @ht1
<ideal @dehom x y 1
ev @dehom @ht1 #5
ev @dehom @htrem #6
copy @h #4
shout echo presentation of the ideal
shout betti @ii
shout pres @ii
shout echo

shout echo "the following remainder is 0 iff the ideal"
shout echo "is of linear type on the punctured spectrum"
shout type #6
shout echo 

shout echo rees ideal, symm ideal
shout betti #2
shout betti #3
shout echo hilb series of quotient, divided by (1-x)^{dim base ring i}
shout type #5
shout echo
setring #1

spare
END:
incr-set prlevel -1

$;;;;;;;; EXAMPLE SECTION ;;;;;;;;;;;;;;;;;;;;;;;;;
reset
<ring 3 a-z R
power R 2 i
<rees-sym i REES SYM H h rem
;3y4-8y3+6y2 

power R 3 i
<rees-sym i REES SYM H h rem
;y9-27y7+105y6-189y5+189y4-105y3+27y2

<ideal j a2 b2 c2-ab ac bc  ;Gorenstein
<rees-sym j rees sym H h rem
;-y6+5y5-10y4+7y3 

<ring 2 a-z r
<ideal i a3 a2b b3
<rees-sym i rees sym H h rem
;xy2+y3 

<ideal i a4 a3b b4
<rees-sym i rees sym H h rem
;x2y2+xy3+y4

<ideal i a4 a2b2 b4    ;not birational
<rees-sym i rees sym H h rem
;x2y2+2xy2+y2            
;NOTE: quadratic terms although the syz matrix is just quadrics

<ideal i a4 a3b+a2b2 b4       birational
<rees-sym i rees sym H h rem
;x2y2+y4+2xy2
;NOTE: quadratic terms although the syz matrix is just quadrics

<ideal i a4 a2b2 b4    ;not birational
power r 5 r5
intersect r5 i i5
res i5 i5
betti i5
<rees-sym i5.1 rees sym H h rem

;2-ic veronese
<ring 3 stu R
<ideal I su-t2 s2 u2 t2
<rees-sym I rees sym H h rem

<ring 3 xyz R
<ideal row1 0 x 0 x+y+7z 0 0 z
<ideal row2 0 0 y 0 0 z 0
<ideal row3 0 0 0 x z 0 0
<ideal row4 0 0 0 0 y 0 0
<ideal row5 0 0 0 0 0 x 0
<ideal row6 0 0 0 0 0 0 y
<ideal row7 0 0 0 0 0 0 0
<stack m row1 row2 row3 row4 row5 row6 row7
transpose m m'
subtract m m' n
type n
betti n
setdegs n
;
;
betti n
res n nn
transpose nn.2 i
betti i
flatten i i
<rees-sym i rees sym H h rem
;-3y8+21y7-64y6+102y5-84y4+29y3 


<ring 2 st p1
<ideal params s4 s3t st3 t4
<ring 4 a-z r
<subring params i
power r 3 rpower
intersect rpower i i
res i ii
betti ii
<rees-sym i rees sym H h rem
;y5-5y3+5y2 

<ring 2 st p1
<ideal params s4 s2t2 st3 t4
<ring 4 a-z r
<subring params i
power r 3 rpower
intersect rpower i i
res i ii
betti ii
<rees-sym i rees sym H h rem
; -2y6+4y5+3y4-12y3+8y2

<ring 2 st p1
<ideal params s5 s4t  st4 t5
<ring 4 a-z r
<subring params i
power r 4 rpower
intersect rpower i i
res i ii
betti ii
<rees-sym i rees sym H h rem
; couldn't do it!

<ring 3 abc r
<gaeta r 7 i
power r 4 rpower
intersect rpower i i
res i ii
betti ii
<rees-sym i rees sym H h rem
;3y7-10y6+6y5+15y4-25y3+12y2 

<ring 3 abc r
<ideal row1 a b2 c3
<ideal row2 b c2 a3
<stack i row1 row2
wedge i 2 i
flatten i i
power r 5 rpower
intersect rpower i i
res i ii
betti ii
<rees-sym i rees sym H h rem
;6y9-35y8+78y7-70y6-14y5+84y4-70y3+22y2 

<ring 3 xyz N
<subring i K
type K


putmat rees


;;;;;;;;;;;;;

modulo rees symalg kernel
<prune kernel kernel
res kernel kernel
betti kernel
degree kernel.1



;compute the a,b bigraded part of rees/symalg,
;that is, the part of degree a in x an 

int a 0
int b 2

power xvars a xa
power xvars a+1 xaplus
power yvars b yb
power yvars b+1 ybplus
<mult_ideals xa yb xayb
<mult_ideals xaplus yb xaplusyb
<mult_ideals xa ybplus xaybplus

intersect rees xayb reesab
intersect rees xaplusyb reesaplusb
intersect rees xaybplus reesabplus
intersect symalg xayb symalgab
copy symalgab kerab
concat kerab reesabplus reesaplusb
modulo reesab kerab m

<prune m m
betti m
