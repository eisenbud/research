--needsPackage "ReesAlgebra2"

needs "randomIdeal.m2"

yReesReg= i->(
     I:=reesIdeal(i,i_0);
     f:=(flattenRing I)_1;
     regularity (f I, Weights=>{1,0}))
xReesReg = i ->(     
     I:=reesIdeal(i,i_0);
     f:=(flattenRing I)_1;
     regularity (f I, Weights=>{0,1}))

reesRegs = i-> (
     --output is (xReesReg, yReesReg)
     I:=reesIdeal(i,i_0);
     f:=(flattenRing I)_1;
     FF=res(f I);
     regularity (FF, Weights=>{0,1}), regularity (FF, Weights=>{1,0}))

fiberReg = i ->  regularity(specialFiberIdeal(i,i_0), Weights => {1,0})

YReesReg1= i->(
iR=reesIdeal(i,i_0);
(RRR, f)=newring(ring iR,{1,1});
newI= f iR;
regularity betti (res newI, Weights=>{1,0})
)

YRRvYFR=method(Options=>{Verbose => true})
YRRvYFR Ideal := o-> i -> (
     --compare the y-rees regularity with that of the fiber ring:
     iR:=reesIdeal (i,i_0);
     f:=(flattenRing iR)_1;
     iR1 = f iR;
     yRR=regularity (iR1, Weights=>{1,0});
     iF:=iR1+ideal sub(vars ring i, ring iR1);
     yFR=regularity (iF, Weights=>{1,0});
     if not o.Verbose and yRR!= yFR then (
     print i;
     print (yRR,yFR);
     ) else  if o.Verbose then print (yRR, yFR))


///
--compare the regularity of the fiber ring with that of the Rees ring.
--Always equal in the case of a primary ideal gen by forms of same degree?
--yes for lots of monomial and nearly monomial examples with few
--generators, as below.

restart
load "reesRegs2.m2"

S=kk[x,y]
i=ideal"x5,y5, x3y2"
iR=reesIdeal i
yReesReg i
fiberReg i
YRRvYFR (i, Verbose => false)
YRRvYFR (i)
reesRegs i

S=kk[x,y,z,u]
j=ideal(x^3,y^3,z^3,u^3,x*y*z+x*y*u)
yReesReg j

jR=reesIdeal j
f=(flattenRing jR)_1
res (f jR)
--time res jR --very slow -- didn't finish in 1.5 min, seemed to need a lot of space!
res((flattenRing ring jR)_1 jR) -- very fast.

--if the option Verbose => false is given, then
-- YRRvYFR returns a value only if the fiber ring and
--the rees algebra have different multiplicities. We know no example
--of a zero-dimensional ideal generated by forms of a single degree
--for which that is the case!

S=kk[x,y,z,u]
d=4
i0=ideal(x^d, y^d, z^d,u^d)
time for p from 1 to d-1 do(
     for q from 1 to d-p do(
	  for m from 0 to d-p-q do(
	  r=d-p-q-m;
	  print(p,q,m,r);
     	  for p1 from 1 to d-1 do(
	         for q1 from 1 to d-p1 do(
		      for m1 from 1 to d-p1-q1 do(
	  r1=d-p1-q1-m1;
	  YRRvYFR (i0 +ideal(x^p1*y^q1*z^r1*u^m1+x^p*y^q*z^r*u^m), Verbose => false)))))))
///


------Towards a general computation of the assymptotic degree and assymptotic regularity------

regfunction = (i) -> (
     yr:=yReesReg i;
     bBound := max(1,yr);
     r0:=regularity i^bBound;
     r1:=regularity i^(bBound+1);
     d:= r1-r0;
     e:= r0-bBound*d;
     use ring i;
     (yr, d, e)
     )

stabilization = i->(
     yr:=yReesReg i;
     bBound := max(1,yr);
     r0:=regularity i^bBound;
     r1:=regularity i^(bBound+1);
     d:= r1-r0;
     e:= r0-bBound*d;
     j=1;
     while regularity i^j != d*j+e do j=j+1;
     j)

iExample= (d,a,b)->ideal(x^d,y^d, x^a*y^(d-a), x^b*y^(d-b))

///
restart
load "reesRegs2.m2"
kk=ZZ/101
S=kk[x,y]
i=iExample(5,2,3)
regfunction i
stabilization i
///

orderedMinGens = i-> sort(mingens i, DegreeOrder=>Ascending)
--produces the minimal generators of i, in order of increasing degree.

assymptoticDegree = method()
assymptoticDegree(Ideal, Module, RingElement) := (i,M,u) ->(
     --takes an ideal and a module over a polynomial ring, returns the
     --assymptotic degree of the generators of the module on the ideal,
     --that is, the smallest degree d such that 
     --R(i,M) = R(i)M, the Rees algebra of I on M,
     -- is finite over R(i_{<=d}). Note that only the annihilator of M matters.
     --If j=i(R/ann M), then this is also the smallest degree so that j is integral
     --over j_{<= d}.
     --Also, because everything is graded, we may check finiteness by "Nakayama's Lemma".
     --
     --u must be an element of i that is outside each minimal prime of M.
     igens := orderedMinGens i;
     A:= annihilator M;
     R:=(ring i)/A;
     jgens := substitute(igens,R);
     I:=reesIdeal(ideal igens, u);
     xVars:=ideal substitute(vars ring i, ring I) ;
     J:=mingens(I+xVars);
     T:=(ring I)/ideal J;
     s:=dim T-1;
     ti:=ideal((vars T)_{0..s});
     while (dim (T/ti))>0 do (
     	  s=s+1;
	  ti=ti+ideal(T_s));
--     print s;
     (degree igens_s)_0
     )

assymptoticDegree(Ideal):= i -> assymptoticDegree(i, (ring i)^1, i_0)

///
restart
load "reesRegs2.m2"

kk=ZZ/101
S=kk[x,y]
--handy for making easy examples in kk[x,y]
assymptoticDegree ideal"x5,x7+xy7, x8"
///

-------Compute the modules generalizing the special fiber (case of ideal generated
--in a single degree only!
push = method()
push(Ideal, ZZ):= (i,e)->(
     --takes an m-primary ideal i generated in a single degree in a polynomial ring S
     --and a positive integer e. Forms a polynomial ring T whose generators (which have deg 1)
     --correspond to the generators of i. 
     --returns the module over T generated by the forms of degree e in S.
kk:=ZZ/(char S);
S:=ring i;
T1:=kk[A_1..A_(numgens i),Degrees=>last degrees gens i];
F:=map(S,T1,gens i);
Ne:=presentation pushForward(F,module((ideal vars S)^e));
n:=numgens ((ideal vars S)^e);
Me:=transpose (sort(transpose Ne,DegreeOrder=>Descending));
T:=kk[A_1..A_(numgens i)];
f:=map(T,T1);
M= f Me;
p=map(target M, T^{n:-e},(i,j)->if i==j and i<=n-1 then 1_T else 0_T);
q=map(target M, target M, (i,j) -> if i==j and i>=n then 1_T else 0_T);
minPres( (target M)/((intersect(image p, image M))+(image q)))
)     

push(Ideal, Ideal, ZZ) := (i,j,e)->(
     --takes  m-primary ideals i \supset j,
     --both  generated in some degree d in a polynomial ring S over a field k,
     --and a positive integer e. Forms a polynomial ring T whose generators (which have deg 1)
     --correspond to the generators of j
     -- generated over k[i_d] by the forms of degree e in S, written as a module over T.
S:=ring i;
kk:=ZZ/(char S);
T1:=kk[A_1..A_(numgens i),Degrees=>last degrees gens i];
F:=map(S,T1,gens i);
Ne:=presentation pushForward(F,module((ideal vars S)^e));
n:=numgens ((ideal vars S)^e);
Me:=transpose (sort(transpose Ne,DegreeOrder=>Descending));
T:=kk[A_1..A_(numgens i)];
f:=map(T,T1);
M:= f Me;
p:=map(target M, T^{n:-e},(i,j)->if i==j and i<=n-1 then 1_T else 0_T);
q:=map(target M, target M, (i,j) -> if i==j and i>=n then 1_T else 0_T);
M1:=minPres( (target M)/((intersect(image p, image M))+(image q)));
U:=kk[B_1..B_(numgens j)];
mat := sub((gens j)//(gens i), T);
G:= map(T,U,(vars T)*mat);
pushForward(G,M1)**U^{e}
)     

///
--conjecture: when i is 0-dimensional and generated in just one
--degree, then reg N_t is a non-increasing function. We know this
--is true when t\geq e, and thus in particular we know it's true
--when e=0, that is, the map defined by i_d is an embedding.

--example where i is a power of the maximal ideal in a polynomial ring;
--what are the modules N_t? In this case the fiber ring is the
--ring of the veronese. 

restart
load "reesRegs2.m2"

test=(n,d) ->(
S=kk[x_1..x_n];
i=(ideal vars S)^d;
for a from 0 to 5 do (
     print betti res push(i,a);
     print"";
     ))
-- test(2,d) are nice:
--in that case, the resolutions are pure, and they run through all the pure
--resolutions of something CM of dim 2, and reg 2,  and then become reg 0 and (presumably) dim 1.
--test(3,3) and test(4,2) are rather mysterious and interesting.
test(4,2)
test(2,5)

--A series with 2 ideals
test=(n,d)->(
     S=kk[x_1..x_n];
     m=ideal vars S;
     for a from 0 to 5 do (
     	  print  betti res (M=push(m^d, m^[d], a));
     	  print"")
     )
test(2,4)

kk=ZZ/101
S=kk[x,y,z]
m=ideal vars S
d=2
i=m^d 
i=m^[d]+ideal random(S^1,S^{2:-d})
j=m^[d]
for a from 0 to 5 do (
     print betti res (P=push(i,j,a));
     print""
)

///
---------------tested to here--------------

h1Reg=i->(
     --compute the degrees of the generators of
     --(x)*(y) socle of H_(y)^1 of the Rees algebra,
     --and perhaps also the H^1 module presentation.
     iR:=reesIdeal(i,i_0);
     (RRR, f):=newring1(ring iR,numgens i);
     newI:= f iR;
     --the y-variables
     n:=ideal (RRR_0..RRR_((numgens i) -1));
     --the x variables
     m:=ideal (RRR_(numgens i)..RRR_((numgens RRR) -1));
     --print the bidegrees of the socle generators. second degrees are the x, first are the y.
    s:=last degrees mingens (((newI+ideal(RRR_0)):(n))/(newI+ideal(RRR_0)));
    g:=last degrees mingens (saturate((newI+ideal(RRR_0)),n)/(newI+ideal(RRR_0)));
--     print s;
     os = organize s;
     og = organize g;
     print organize s;
--     print g;
     print organize g;     
     print("");
--     if not (testFirstDecreasing os and testFirstDecreasing og) then(
     if not (testFirstDecreasing og) then(
   	  print i; error("counterexample"));
     (s, g))

organize = s ->(
     --s is a llist of lists {a,b}. function returns a list of pairs
     --whose first elements are the maximum a for each b, followed by b,
     --in increasing order of b.
     lasts =unique sort( for t from 0 to #s-1 list (last s_t));
     start = min lasts;
     stop = max lasts;
     for t from 0 to #lasts-1 list(
	  st:=select(s, p-> last p == lasts_t);
	  stmax:=max (for u from 0 to #st-1 list first st_u);
	  {stmax, lasts_t})
     )

testFirstDecreasing= L ->(
     -- for a list of lists {a,b}, tests whether 
     --the sequence of a's is weakly decreasing.
     v:= true;
     for t from 0 to #L-2 do(
	  if first(L_(t+1))>first(L_t) then v=false);
     v)

regularities = i->(
--     s:=stabilization i;
     e:=(regfunction1 i)_2;
     for t from 1 to e list(
     M0=push(i,t);
     R:=ring M0;
     R0:=R/ideal(R_0);
     f:=map(R0^(numgens i),R0^{-1}, transpose vars R0);
     r:=(regularity M0)-t;
     K:=kernel(f**(R0**M0));
     {r,max (flatten last degrees mingens K)-t-1}
     )
)

pushCheck= i -> (
     d:=(degree i_0)_0;
     yr:=YRR i;
--     <<"YRegularity="<<yr;
     eps:=regularity i^yr - yr*d ;
--     <<", epsilon="<<eps <<endl;
     r0:=regularity push(i,0);
     for e from 1 to eps do(
     	  r1:=regularity push(i,e)-e;
	  if r1>r0 then (
	       print i;
	       print yr;
	       print eps;
	       error("counterexemample found!"))
	  else r0= r1)
     )

pushCheck1 = i -> (
     d:=(degree i_0)_0;
     yr:=YRR i;
--     <<"YRegularity="<<yr;
     eps:=regularity i^yr - yr*d ;
--     <<", epsilon="<<eps <<endl;
     L:=(for e from 0 to eps list(
     	  regularity push(i,e)-e));
    print L;
     if isDecreasing L == false then (
	  print i;
	  error("counterexample!"));
     L
     )

isDecreasing = L-> (
     v:=true;
     for i from 1 to length L - 1 do(
	  if L_i>L_(i-1) then v=false);
     v)

///
restart
load "reesRegs2.m2"

S=kk[x,y]
for d from 5 to 14 do(
time for a from 1 to d//2 do(
     for b from a+1 to d-1 do(
	  L=regularities  iExample(d,a,b);
	  if not  (isDecreasing (L/first) and isDecreasing (L/last)) then (
	       print("the following is a counterexample"));
	       print(d,a,b);
	       for t from 0 to length L -1 do (
		    if last L_t != -infinity and first L_t != last L_t then print(L));
	  )))

d=10;d1=5
i=ideal(x^d)+ (ideal vars S)^(d-d1)*ideal(y^d1)
regularities i

regfunction1 iExample(20,4,16)     
regularities iExample(20,4,16)


--the regularity of N_i is  decreasing, 
--BUT the  regularity of H^1 is NOT.
--nevertheless the h1-regularity of N_0 is the biggest, in examples.

--check whether the regularity of push(i,e) is decreasing with e
--Always in the case of primary ideals generated in a single degree d.
--We KNOW this is the case starting with e = \epsilon, the
--assymptotic excess regularity, so we only need to check up to there.
--Note that push(i,0) is the regularity of the ring k[i_d], which in
--this case is the fiber ring.


kk=ZZ/101
S=kk[x,y]
i=ideal"x4,x3y,  y4"
pushCheck1 i
pushCheck i

i=ideal"x20,y20,x16y4,x4y16"
i=ideal"x20,y20,x18y2,x2y18"
pushCheck1 i

test=(n,d,N)->(
     --test N binomial ideals of degree d in n variables
     R=ZZ/101[Z_1..Z_n];
     for t from 1 to N list(
	  i=ideal(0_R); 
	  while (codim i) < n do(
          i=randomBinomialPrimaryIdeal(d,R,1+random(2));
	  );
     pushCheck1 i)
)
S=kk[x,y,z]
tally test(3,4,100)

d=4
S=kk[x,y,z]
i0=(ideal vars S)^[d]


time for t from 1 to 10 do pushCheck(i0+randomMonomialIdeal(S,d,1))

///

purePowers=(d,S)->for t from 0 to numgens S - 1 list (S_t)^d
impure=(d,S)->(
     c:=compress(basis(d,S)%map(S^1,S^{numgens S:-d}, matrix{purePowers(d,S)}));
     for i from 0 to rank source c -1 list c_(0,i))
     

randomBinomialPrimaryIdeal=(d,S,g)->(
     --numgens+g generators; the first chosen with a pure power as half.
     kk=coefficientRing S;
     P:=purePowers(d,S);
     Q:=impure(d,S);
     m:=length Q;
     L:=for t from 0 to numgens S-1 list P_t-(random kk)*Q_(random (m-1));
     L1:=for t from 1 to g list Q_(random (m-1))-(random kk)*Q_(random (m-1));
     ideal mingens ideal(L|L1))

randomPrimaryIdeal=(d,S,g1,g2)->(
     --numgens+g1+g2 generators; the first numgens chosen to be d-th powers of the variables.
     --g1= number of monomials other than the powers
     --g2= number of binomials.
     kk:=coefficientRing S;
     P:=purePowers(d,S);
     Q:=impure(d,S);
     m:=length Q;
     h:=0;
     L:=for t from 1 to g1 list Q_(random (m-1));
     L1:=for t from 1 to g2 list Q_(random (m-1))-(random kk)*Q_(random (m-1));
     ideal mingens ideal(P)+ideal(L|L1)
     )

///
restart
load "reesRegs.m2"
kk=ZZ/101
S=kk[x,y,z]

for t from 1 to 100 do(
I=randomPrimaryIdeal(3,S,2,0);
print (L:=regularities I);
for u from 0 to #L-1 do(
     if (last(L_u) != -infinity and last (L_u) != first (L_u)) then(
	  print  toString I);
     )
)

S=kk[x,y,z]

for d from 2 to 5 do(
i = (ideal vars S)^d;
for t from 0 to 5 do print (regularity push(i,t)-t);
print("");)


i=ideal(w^3,z^3,y^3,x^3,x*z*w,y^2*w)
i=ideal(w^3,z^3,y^3,x^3,y*z^2,x*w^2)

betti res push(i,3)
betti res M



entry=(d,e)->(
i=(ideal vars S)^d;
M=push(i,e);
regularity push(i,e)
)
n=3
entry1=(d,e)->(
   ((max(d-1, n*(d-1)-e))//d)+e)
entry1(3,4)
map(ZZ^10, ZZ^10, (d1,e)->entry1(d1+1,e))

S=kk[x,y]
map(ZZ^10, ZZ^10, (d1,e)->entry(d1+1,e))
o39 = | 0 1 2 3 4 5 6 7 8 9 |
      | 1 1 2 3 4 5 6 7 8 9 |
      | 1 2 2 3 4 5 6 7 8 9 |
      | 1 2 3 3 4 5 6 7 8 9 |
      | 1 2 3 4 4 5 6 7 8 9 |
      | 1 2 3 4 5 5 6 7 8 9 |
      | 1 2 3 4 5 6 6 7 8 9 |
      | 1 2 3 4 5 6 7 7 8 9 |
      | 1 2 3 4 5 6 7 8 8 9 |
      | 1 2 3 4 5 6 7 8 9 9 |

S=kk[x,y,z]
--map(ZZ^3, ZZ^8, (d1,e)->entry(d1+1,e))
o6 = | 0 1 2 3 4 5 6 7 |
     | 1 2 2 3 4 5 6 7 |
     | 2 2 3 4 4 5 6 7 |

entry(4,0)--2
entry(4,1)
restart
load "reesRegs.m2"
kk=ZZ/101
S=kk[x,y]
i=ideal"x4, xy3,y4"
Me= push(i,2)
regfunction i
for e from 0 to 7 do print (regularity push(i,e))

X=map(S^{0,-1},S^0,matrix{{};{}})


load "reesRegs.m2"
kk=ZZ/101
S=kk[x,y,z]
i=ideal "x4,x3y,x3z, y4,z4, z3y"
d=5
i=ideal(x^d,x^(d-1)*y, x^(d-1)*z, y^d, z^d, z^(d-1)*x, z^(d-1)*y,x^(d//3)*y^(d//3)*z^(d-2*(d//3)))
i=ideal(x^d,x^(d-1)*y, x^(d-1)*z, y^d, z^d, z^(d-1)*x, z^(d-1)*y)
regfunction i
for t from 1 to 5 do print  regularity i^t
for e from 0 to 9 do print (e, regularity push(i,e))

restart
load "reesRegs.m2"
kk=ZZ/101
S=kk[a,b,c,d]
i2=ideal(vars S)^[2]
j=ideal"ab,ac,ad"
i=i2+j
i=i2
regfunction i
for t from 1 to 5 do print  regularity i^t
for e from 0 to 9 do print (e, regularity push(i,e))


///


--given 
--a polynomial ring S, with ideal I
-- primary to the maximal ideal M (note: the number of vars doesn't occur!)
--d= degree of all the generators of I
--E the sequence of assymptotic degrees of I, that is,
--e_p=E_(p+1) where reg I^p = dp+e_p
--k a positive integer,
--The program outputs a list of the assymptotic degrees of 
--I+M^(d+k). 
--The same number of values are output as are given in L.
eList=method()
eList(ZZ,List,ZZ) := (d,E,k) ->(
     e:=p->E_(p-1);
     P0:=for l from 1 to #E list (p=1;
	  while d*p+e(p)<(d+k)*l-k*p do p=p+1;
	  p);
     p0:=l->P0_(l-1);
     for i from 1 to #E list min(d*p0(i)+e(p0(i)), (d+k)*i - k*(p0(i)-1))-d*i
     )

///
restart
load "reesRegs.m2"
E = {12, 12, 12, 12}
eList(5,E,1)

--example of a regular sequence of n forms of degree d plus m^(d+k).
--len = length of output desired.
eListRegSeq=(n,d,len) -> for i from 1 to len list (n-1)*(d-1)
exRegSeq=(n,d,k,len)->eList(d,eListRegSeq(n,d,len),k)
exRegSeq(7,9,1,10)

--example where I has eList = L, and we output the eList of IM^t
eListIMt=(L,t) -> for i from 1 to #L list max(0,L_(i-1)-t*i)
eListRegSeq(5,5,10)
eListIMt(eListRegSeq(5,5,10),1)

--and now add the next power of M:
eList(5,eListIMt(eListRegSeq(4,4,10),1),1)

eList(6,7,{12,12,12,12,12}, 1)
///





end  
restart
kk=ZZ/101
S=kk[x,y]
Iexample=(a,b,c,d)->ideal(x^a, y^b, x^c*y^d)
a=11
b=10
for c from 2 to 10 do for d from 2 to 9 do (
     t=7;
     i=Iexample(a,b,c,d);
     print (a,b,c,d,"=>",max(a+d,b+c)-2-a+1==(regularity(i^t)) - t*a);
     print(d-1==(regularity(i^t)) - t*a)
)
i=Iexample(11,10,10,1)
for t from 1 to 10 do print regularity i^t
regfunction i
--Daffyd: 
restart
load "reesRegs.m2"
kk=ZZ/101

S=kk[x,y]
use S
i=ideal"x4,x3y, xy3,y4"
i=ideal"x4, xy3,y4"
i=ideal"x6, x4y2, xy5,y6"
i=ideal"x6,x4y2, xy5,y6"
d=4

kk=ZZ/101
S=kk[x,y,z]
i=ideal "x4,x3y,x3z, y4,z4, z3y"
d=6
i=ideal(x^d,x^(d-1)*y, x^(d-1)*z, y^d, z^d, z^(d-1)*x, z^(d-1)*y)
regfunction i
 for t from 1 to 5 do print  regularity i^t
randomFromIdeal(i,4,2)
(gens oo) % gb i

restart
load "reesRegs.m2"

kk=ZZ/101
S=kk[x,y]
for d from 4 to 15 do(
     use S;
     i1=ideal(x^(d//2));
     j1 = ideal product(1..(d//2), i->(x-i));
     m=ideal(x,y);
     print d;
--     print regfunction(i1*m^(d-(d//2))+ideal random(S^1,S^{-d}));
--     print regfunction(j1*m^(d-(d//2))+ideal random(S^1,S^{-d}));
     print regfunction(randomFromIdeal(i1,d,2)+ideal(y^d));	       
     use S;
     print regfunction(randomFromIdeal(j1,d,2)+ideal(y^d));  
     )


--in 2 variables, seems the worst we get is yreg-e, achieved by x^d, x^d-e-1, xy^d-1, y^d
kk=ZZ/101
S=kk[x,y,z]
i=ideal "x4,y4,z4,x2y2,x2z2,xy3,y2z2,yz3,xz3"
yr=YRR i
for m from 1 to yr+3 do print regularity i^m
iR=reesIdeal(i,i_0)
use ring iR
(RRR, f)=newring(ring iR,{1,1});
J=trim (iR+ideal(x,y,z))
K=f J
degrees vars RRR
betti (res (f J),Weights=>{1,0})

restart
load "reesRegs.m2"
kk=ZZ/101
n=3
S=kk[x_1..x_3]
use S
i=((ideal(x_1..x_2))^[3])*(ideal vars S)+ideal(random(S^1, S^{-4}))
betti res i
yr=YRR i
for m from 1 to yr+2  do print regularity i^m
 
iR=reesIdeal(i,i_0)
use ring iR
(RRR, f)=newring(ring iR,{1,1});
J=trim (iR+ideal(x,y,z))
K=f J
degrees vars RRR
betti (res (f J),Weights=>{1,0})


d=6
i=ideal random (S^1, S^{3:-d})
for m from 1 to yr+3 do print regularity i^m
yr=YRR i
--for 3 generic forms in 2 vars of deg d, we get y-regularity d-1, e is 1, stab is d-2.


I=reesIdeal(module i, i_0)
degrees vars ring I
yRR i

regfunction i
for t from 1 to 5 do print regularity(i^t)

yRR i

R=ZZ/101[a..e]
I=monomialCurveIdeal(R, {1,2,3,5})
RI=reesAlgebra(I)
degrees vars ring RI
S=ring RI
C=res RI
betti C

bBound = xRR I -- 
m=stabilizationBound I
regList = apply(1..m, i-> regularity(I^i))
a = regList#(m-1) -regList#(m-2)
b = apply(1..m-1, i-> regularity(I^i)-a*i)


I=monomialCurveIdeal(R, {1,2,3,6})
RI=reesAlgebra(I)
bBound = xRR I -- 
m=stabilizationBound I
regList = apply(1..m, i-> regularity(I^i))
a = regList#(m-1) -regList#(m-2)
b = apply(1..m-1, i-> regularity(I^i)-a*i)

--------------------------------

restart	  
load "reesRegs.m2"
kk=ZZ/101
--S=kk[x,y]
--

S=kk[x,y]
I=ideal"x6,y11,x5y10"
RI=reesAlgebra(I)
bBound = xRR I -- 
m=stabilizationBound I
regList = apply(1..10, i-> regularity(I^i))
a = regList#(m) -regList#(m-1)
b = apply(1..m-1, i-> regularity(I^i)-a*i)


R=ZZ/101[x,y,u,v]
d=3
test = d -> ( 
I := ideal(x^d, y^d, u^(d-1)*x-v^(d-1)*y);
-- regularity(I)
RI := reesAlgebra(I);
S := ring RI;
weightedBetti(betti res RI,{0,1});
print (stabilize := maxTwist weightedBetti(betti res RI, {0,1}));
print (bBound := xRR I - 1) ; 
regList := apply(stabilize, i-> regularity(I^i));
print (apply(length(regList)-1, i -> regList#(i+1)-regList#i)); 
print "a="; print (a := regList#(stabilize-1) -regList#(stabilize-2));
print (remList = apply(stabilize, i-> regularity(I^i)-a*i));
print (b := last remList);
)
test 3


--------- Oct 18 2008
--test pure powers plus power of the max ideal.
restart
load "reesRegs.m2"
kk=ZZ/101
n=4
S=kk[x_1..x_n]
d=5
k=1
test=(d,k,m)->(
--     i1=(ideal vars S)^[d];
     i1=(ideal vars S)*(ideal vars S)^[d-1];     
     i2=(ideal vars S)^(d+k);
          i=trim(i1+i2);
--       i=trim((ideal vars S)*i1);
for s from 1 to m do print ((time regularity i^s)-s*(d)))
--n*(c-1)+1
i
betti i
YRR i
test(5,1,5)

------------
-- and ideal where gr is CM, but the assympt gen degree (=3) is not the max deg of a gen.
--note that the assymp excess regularity is constant
S=kk[x,y]
i=ideal"x3,y3,x2y2"


for p from 1 to 6 do print(( regularity i^p) - 3*p)

---
--random monomial ideals in 2 variables:
restart
load "randomIdeal.m2"
kk=ZZ/101

diffs=L->(
     for i from 1 to #L-1 list L_(i-1)-L_i)
isDecreasing=L->(val:=true;
     for i from 1 to #L-1 do if L_(i-1)<L_i then val=false;
     val)
S=kk[x,y,z]
d=10
k=25
B=flatten entries gens (ideal(gens S))^d;
     for j from 1 to 100 do(
     i1=randomSparseIdeal(B, 1, k);
     i=trim ((ideal vars S)*ideal(vars S)^[d-1])+i1;
     t1 = isDecreasing (L=for m from 1 to 5 list (regularity(i^m) - m*d));
     t2= isDecreasing (L1=diffs L);
     if not (t1 and t2) then(
     	   print toString i);
      print(L,L1))



i=ideal"z10,xy2z7, x3z7, x4z6, y6z4, x6y3z, x7y2z,y10, xy9, x3y7, x10"

i = ideal"y20, x20,x2y18,x9y11,x17y3"
(L=for m from 1 to 5 list (regularity(i^m) - m*d))


------------
restart
load "ReesAlgebra.m2"     
S=ZZ/101[x,y,z]
i=trim((ideal vars S)^[4]+(ideal vars S)^5)
-- for m from 1 to 4 do print regularity i^m
-- 1,2,2,...
--what's the depth of the graded ring?
G=normalCone i;
degrees vars G
kernel map(G^1, G^{{-1,-4}},matrix{{w_1}})
--this is zero, so depth is at least 1. Seems not to be 2.


S=ZZ/101[x,y,z,w]
i=trim((ideal vars S)*(ideal vars S)^[4]+(ideal vars S)^6)
for m from 1 to 4 do print regularity i^m
-- 1,2,2,1,...
--what's the depth of the graded ring?
G=normalCone (i,x);
degrees vars G
kernel map(G^1, G^{{-1,-4}},matrix{{w_1}})
--this is zero, so depth is at least 1. Seems not to be 2.




--------------Example2.2 of the paper
