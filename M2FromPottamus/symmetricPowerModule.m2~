--Given a module M over a ring S, and an integer p, --symmetricPowerModule(p,M) --returns the p-th symmetric power of M.restart--TO FIX:--  1. find out how to do local variables in the def of T--  2. We could do exterior powers, except that we'd need to take--  the degrees of the vars of T to be 1. Maybe--  introduce a bigrading into T, use one grading to determine--  that the variables are "exterior" (of odd degree), and the other--  grading to record the grading in M. This would require more list-processing-- than I'm ready for.--  3. What's the order of basis elts-- in the target free module-- (ie, what's the-- sort order of the elements of the power ideal?). -- Does NOT seem to depend on the degrees of-- the gens of M in case these come with different degrees.symmetricPowerModule=(p,M)->(--First get the data on Mphi := presentation M;F := target phi;G := source phi;--pass to a new ring with variables corresponding to the --generators of F (degrees included!)n:=rank F;L:=flatten degrees F;T:=ZZ/2[vars(0..n-1), Degrees=>L]; --Are the variable names non-conflicting in the above?? --make --         mult: vars**(deg p-1 monoms) --> (dep p monoms)-- as a map of free T-modulesmp:=forceGB gens (ideal vars T)^p;mm:=(vars T)**(gens(ideal vars T)^(p-1));mult:=mm//mp;--move back to the ring of Mmult1:=substitute(mult,ring M);Fp:=substitute(source gens (ideal vars T)^(p-1), ring M);--and combine with phi\otimes 1coker (mult1*(phi**Fp)))endrestartload "symmetricPowerModule.m2"--parameters for a trial:kk=ZZ/101S=kk[x,y,z]M= module (ideal vars S)^2p=3time N=symmetricPowerModule(3,module (ideal vars S)^5);--36.07 secs on pinch, .2 secs on Harley!hilbertFunction(5, N)i=(ideal vars S)^1N=symmetricPowerModule(3, module i)