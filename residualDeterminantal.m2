{*
If i>= reduction number (q-p-1 if p=2; in general) then I^i/JI^(i-1) \cong \omega_{R/K}. It is CM with
linear resolution, and self-dual.

Set:
q = n-p
s = p*q
r = p*q+1-p-q

for i>=r, and J generated by exactly s general elements it seems that I^i/JI^(i-1) is CM of codim s
and all isomorphic to omega_{R/K}, independent of i.
*}


load "SymmetricPower.m2"

--programs to extract the list of total betti numbers from a BettiTally
totalBetti = method()
totalBetti(ZZ,BettiTally) := (j,B) ->(
     Bj := select(keys B, k->k_0==j);
    sum(Bj, k->B#k))
totalBetti(ZZ,Module) := (j,M) -> (
    totalBetti(j, minimalBetti M))
totalBetti BettiTally := B->(
    len = max apply(keys B, k->k_0);
    apply(len+1, j -> totalBetti(j,B)))
totalBetti Module := M ->(
    totalBetti minimalBetti M)
totalBetti Ideal := I -> totalBetti minimalBetti I
totalBetti (ZZ,Ideal) := (j,I) -> totalBetti (j, minimalBetti I)


detPower = {p,n,k} ->(
R := ZZ/101[x_(0,0)..x_(p-1,n-1)];
m := transpose genericMatrix(R, x_(0,0),n,p);
I := minors(p,m);
trim (I^k)
)

fastExt = (i,I) ->(
    --returns Ext^i(ring I/I,R)
    F := res(I, LengthLimit => i+1, FastNonminimal =>true);
    (kernel transpose F.dd_(i+1))/image transpose F.dd_(i)
    )
rand = (I,s,d) ->
    ideal ((gens I)*random(source gens I, (ring I)^{s:-d}))
end--
restart
load "residualDeterminantal.m2"
--q := n-p
--look at depths of powers: (stab at value = analyt spread = (pn -p^2+1). 
--Note red num = pq-p-q+1 = (p-1)n-p^2+1
--2 x 4 matrix: R/det^i has depth 3 for all i>=2.
--2 x 5 matrix: R/det^i has depth 3 for all i>=2. pd's 7,7...
--2 x 6 matrix: R/det^i has pd 9 for all i>=2.
--3 x 5 -- pd's are 3,5,7,7...
--3 x 6 -- pd's 4,7,10...-- 

--test the depths of powers
(p,n) = (2,5) -- runs out of Heap for 3,6
num = 2
cod = n-p+1
I = apply(num, j->detPower(p,n,j+2));
apply (num, j->(
time	print pdim minimalBetti ((ring I_j)^1/I_j);
	flush;))

apply(num, j-> prune fastExt(cod+j+2,I_j))

--test whether the crucial I^r/JI^(r-1) is MCM of codim s
restart
load "residualDeterminantal.m2"
(p,n) = (3,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

j= 3
apply(1, u->(i = s;
I = detPower(p,n,1);
R= ring I;
J = ideal ((gens I)*random(source gens I, (ring I)^{i:-p}));
--print minimalBetti J;
print minimalBetti (module(I^j)/module(J*I^(j-1)));
))

--2 x n for n <= 7, the module I^r/JI^(r-1) has linear resolution of length s.
--3 x5 , the module I^r/JI^(r-1) has linear resolution of length s.
--3x5: we tried to compute the pd mod 5 general elements and it was slow


--J_ell and J_(ell-1)
restart
load "residualDeterminantal.m2"

(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1

I = detPower(p,n,1)
Jell = rand(I,ell,p)
Jell' = ideal((Jell_*)_{0..ell-2})
minimalBetti (module(Jell)/module(Jell'))
minimalBetti (rand(I,s,2):I)
minimalBetti Jell

--canonical module?
restart
load "residualDeterminantal.m2"
(p,n) = (3,5) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1);
mm = ideal vars ring I
Jell = rand(I,ell,p);
--(gens trim (mm*I))% Jell
Js = rand(I,s,p);
M = module(I^r)/module(Js*I^(r-1));
time K = Js:I;
time minimalBetti M

time omega =  fastExt(s,K)
