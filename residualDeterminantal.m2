{*
If i>= reduction number (q-p-1 if p=2; in general) then I^i/JI^(i-1) \cong \omega_{R/K}. It is CM with
linear resolution, and self-dual.

Set:
q = n-p
s = p*q
r = p*q+1-p-q

for i>=r, and J generated by exactly s general elements it seems that I^i/JI^(i-1) is CM of codim s
and all isomorphic to omega_{R/K}, independent of i.
*}


load "SymmetricPower.m2"
needsPackage "ReesAlgebra"

--programs to extract the list of total betti numbers from a BettiTally
totalBetti = method()
totalBetti(ZZ,BettiTally) := (j,B) ->(
     Bj := select(keys B, k->k_0==j);
    sum(Bj, k->B#k))
totalBetti(ZZ,Module) := (j,M) -> (
    totalBetti(j, minimalBetti M))
totalBetti BettiTally := B->(
    len = max apply(keys B, k->k_0);
    apply(len+1, j -> totalBetti(j,B)))
totalBetti Module := M ->(
    totalBetti minimalBetti M)
totalBetti Ideal := I -> totalBetti minimalBetti I
totalBetti (ZZ,Ideal) := (j,I) -> totalBetti (j, minimalBetti I)


detPower = {p,n,k} ->(
R := ZZ/101[x_(0,0)..x_(p-1,n-1)];
m := transpose genericMatrix(R, x_(0,0),n,p);
I := minors(p,m);
trim (I^k)
)

fastExt = (i,I) ->(
    --returns Ext^i(ring I/I,R)
    F := res(I, LengthLimit => i+1, FastNonminimal =>true);
    (kernel transpose F.dd_(i+1))/image transpose F.dd_(i)
    )
rand = (I,s,d) ->
    ideal ((gens I)*random(source gens I, (ring I)^{s:-d}))


redNumber = sI ->(
    param := rand(ideal vars ring sI, dim sI,1);
    N := (ring sI)^1/(sI+param);
    assert(dim N == 0);
    i:= 0;
    last (while hilbertFunction(i,N)!=0  list i do i = i+1)
    )
specialFibeIdeal = method()
specialFibeIdeal(Ideal,RingElement):= (I,a) ->(
     Reesi:= reesIdeal(I, a);
     S := ring Reesi;
     --is the coefficient ring of Reesi automatically flattened? NO
     kk := ultimate(coefficientRing, S);
     gS := gens S;
     T := kk[gS, Degrees => {#gS:1}];
     minimalpres := map(T,S);
     sI := trim minimalpres Reesi;
     ell := dim sI;
     r := redNumber sI;
     (sI,ell,r)
     )
conj = I ->(
    d := degree(I_0);
    (sI,ell,r) := specialFibeIdeal(I,I_0);
     <<(ell,r)<<endl;flush;
    J := rand(I,ell-1,d);
    (J:I,prune((module I^r)/module(J*I^(r-1))))
    )

end--
viewHelp ReesAlgebra

restart
load "residualDeterminantal.m2"
--q := n-p
--look at depths of powers: (stab at value = analyt spread = (pn -p^2+1). 
--Note red num = pq-p-q+1 = (p-1)n-p^2+1
--2 x 4 matrix: R/det^i has depth 3 for all i>=2.
--2 x 5 matrix: R/det^i has depth 3 for all i>=2. pd's 7,7...
--2 x 6 matrix: R/det^i has pd 9 for all i>=2.
--3 x 5 -- pd's are 3,5,7,7...
--3 x 6 -- pd's 4,7,10...-- 

--test the depths of powers
(p,n) = (2,5) -- runs out of Heap for 3,6
num = 2
cod = n-p+1
I = apply(num, j->detPower(p,n,j+2));
apply (num, j->(
time	print pdim minimalBetti ((ring I_j)^1/I_j);
	flush;))

apply(num, j-> prune fastExt(cod+j+2,I_j))

--test whether the crucial I^r/JI^(r-1) is MCM of codim s
restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFibeIdeal(I,I_0)

apply(1, u->(i = s;
I = detPower(p,n,1);
R= ring I;
J = ideal ((gens I)*random(source gens I, (ring I)^{i:-p}));
--print minimalBetti J;
print minimalBetti (module(I^r)/module(J*I^(r-1)));
))

--2 x n for n <= 7, the module I^r/JI^(r-1) has linear resolution of length s.
--3 x5 , the module I^r/JI^(r-1) has linear resolution of length s.
--3x5: we tried to compute the pd mod 5 general elements and it was slow


--J_ell and J_(ell-1)
restart
load "residualDeterminantal.m2"

(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1

I = detPower(p,n,1)
Jell = rand(I,ell,p)
Jell' = ideal((Jell_*)_{0..ell-2})
minimalBetti (module(Jell)/module(Jell'))
minimalBetti (rand(I,s,2):I)
minimalBetti Jell

--canonical module?
restart
load "residualDeterminantal.m2"
(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1);
assert(s+1 == dim specialFiberIdeal(I,I_0))
mm = ideal vars ring I
Jell = rand(I,ell,p);
--(gens trim (mm*I))% Jell
Js = rand(I,s,p);
M = module(I^r)/module(Js*I^(r-1));
time K = Js:I;
time minimalBetti M

time omega =  fastExt(s,K)

-----
code methods reesIdeal
uninstallPackage "ReesAlgebra"
installPackage "ReesAlgebra"
viewHelp ReesAlgebra


restart
load "residualDeterminantal.m2"
(p,n) = (2,4) 
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1)
R = ring I
L0 = ideal(I_0,I_5)+rand(I,1,2);
L = ideal apply(L0_*, a -> a^2);
K = L:I;
betti res trim K
gens(K^2)% (L*K)
M = (module K)/module ideal(I_0^2,I_5^2);
minimalBetti M -- doesn't work 
--error: input polynomials/vectors were computed in a non-compatible monomial order
prune Ext^2(M,S);
prune Hom(M,M)

---
--general statement
--assume I equigenerated for simplicity!
restart
load "residualDeterminantal.m2"

S = ZZ/101[a,b,c,d]    
I = ideal"ab,ac,bc,bd,d2"
I = ideal"ab2,ac2,bc2,bd2,d3"
betti res I
(K,M) = conj I
betti presentation M
M' = Ext^3(M,S^{-22})
H = Hom(M,M')
Hp = prune H
pmap = Hp.cache.pruningMap
target pmap
f = homomorphism(pmap*map(Hp,S^1, random(target presentation Hp,S^1)));
prune coker f
betti res M
betti res M'
betti res prune Hom(M,M)
codim K
omega = fastExt(3,K)
prune Hom(omega,omega)


restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFibeIdeal(I,I_0)
(K,M) = conj I;
betti prune M
betti prune Hom(M,M)


restart
--3 x 5 non-generic in 8 vars
load "residualDeterminantal.m2"
S = ZZ/101[a..h]
m = matrix"a,b,c,d,e;
       b,c,h,e,f;
       c,d,e,f,g"
I = minors(3,m)       
(sI,ell,r) = specialFibeIdeal(I,I_0)
(K,M) = conj I;
minimalBetti M
betti(H =  prune Hom(M,M))
minimalBetti H
omega = prune fastExt(6,K);
minimalBetti omega
