{*
If i>= reduction number (q-p-1 if p=2; in general) then I^i/JI^(i-1) \cong \omega_{R/K}. It is CM with
linear resolution, and self-dual.

Set:
q = n-p
s = p*q
r = p*q+1-p-q

for i>=r, and J generated by exactly s general elements it seems that I^i/JI^(i-1) is CM of codim s
and all isomorphic to omega_{R/K}, independent of i.
*}


load "SymmetricPower.m2"
needsPackage "ReesAlgebra"

--programs to extract the list of total betti numbers from a BettiTally
totalBetti = method()
totalBetti(ZZ,BettiTally) := (j,B) ->(
     Bj := select(keys B, k->k_0==j);
    sum(Bj, k->B#k))
totalBetti(ZZ,Module) := (j,M) -> (
    totalBetti(j, minimalBetti M))
totalBetti BettiTally := B->(
    len := max apply(keys B, k->k_0);
    apply(len+1, j -> totalBetti(j,B)))
totalBetti Module := M ->(
    totalBetti minimalBetti M)
totalBetti Ideal := I -> totalBetti minimalBetti I
totalBetti (ZZ,Ideal) := (j,I) -> totalBetti (j, minimalBetti I)


detPower = {p,n,k} ->(
R := ZZ/101[x_(0,0)..x_(p-1,n-1)];
m := transpose genericMatrix(R, x_(0,0),n,p);
I := minors(p,m);
trim (I^k)
)

fastExt = (i,I) ->(
    --returns Ext^i(ring I/I,R)
    F := res(I, LengthLimit => i+1, FastNonminimal =>true);
    (kernel transpose F.dd_(i+1))/image transpose F.dd_(i)
    )

rand = (I,s,d) ->
    ideal ((gens I)*random(source gens I, (ring I)^{s:-d}))


redNumber = sI ->(
    param := rand(ideal vars ring sI, dim sI,1);
    N := (ring sI)^1/(sI+param);
    assert(dim N == 0);
    i:= 0;
    last (while hilbertFunction(i,N)!=0  list i do i = i+1)
    )

specialFibeIdeal = method()
specialFibeIdeal(Ideal,RingElement):= (I,x) ->(
     Reesi:= reesIdeal(I, x);
     S := ring Reesi;
     --is the coefficient ring of Reesi automatically flattened? NO
     kk := ultimate(coefficientRing, S);
     gS := gens S;
     T := kk[gS, Degrees => {#gS:1}];
     minimalpres := map(T,S);
     sI := trim minimalpres Reesi;
     ell := dim sI;
     r := redNumber sI;
     (sI,ell,r)
     )

conj = I ->(
    d := degree(I_0);
    (sI,ell,r) := specialFibeIdeal(I,I_0);
     <<(ell,r)<<endl;flush;
    J := rand(I,ell-1,d);
    (J:I,prune((module I^r)/module(J*I^(r-1))))
    )

isIso = (A,B)->(
    S := ring A;
    H := Hom(A,B);
    Hp := prune H;
    pmap := Hp.cache.pruningMap;
    f := homomorphism(pmap*map(Hp,S^1, random(target presentation Hp,S^1)));
    if prune coker f == 0 then true else false)

end--
viewHelp ReesAlgebra

restart
load "residualDeterminantal.m2"
--q := n-p
--look at depths of powers: (stab at value = analyt spread = (pn -p^2+1). 
--Note red num = pq-p-q+1 = (p-1)n-p^2+1
--2 x 4 matrix: R/det^i has depth 3 for all i>=2.
--2 x 5 matrix: R/det^i has depth 3 for all i>=2. pd's 7,7...
--2 x 6 matrix: R/det^i has pd 9 for all i>=2.
--3 x 5 -- pd's are 3,5,7,7...
--3 x 6 -- pd's 4,7,10...-- 

--test the depths of powers
(p,n) = (2,5) -- runs out of Heap for 3,6
num = 2
cod = n-p+1
I = apply(num, j->detPower(p,n,j+2));
apply (num, j->(
time	print pdim minimalBetti ((ring I_j)^1/I_j);
	flush;))

apply(num, j-> prune fastExt(cod+j+2,I_j))

--test whether the crucial I^r/JI^(r-1) is MCM of codim s
restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFibeIdeal(I,I_0)

apply(1, u->(i = s;
I = detPower(p,n,1);
R= ring I;
J = ideal ((gens I)*random(source gens I, (ring I)^{i:-p}));
--print minimalBetti J;
print minimalBetti (module(I^r)/module(J*I^(r-1)));
))

--2 x n for n <= 7, the module I^r/JI^(r-1) has linear resolution of length s.
--3 x5 , the module I^r/JI^(r-1) has linear resolution of length s.
--3x5: we tried to compute the pd mod 5 general elements and it was slow


--J_ell and J_(ell-1)
restart
load "residualDeterminantal.m2"

(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1

I = detPower(p,n,1)
Jell = rand(I,ell,p)
Jell' = ideal((Jell_*)_{0..ell-2})
minimalBetti (module(Jell)/module(Jell'))
minimalBetti (rand(I,s,2):I)
minimalBetti Jell

--canonical module?
restart
load "residualDeterminantal.m2"
(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1);
assert(s+1 == dim specialFiberIdeal(I,I_0))
mm = ideal vars ring I
Jell = rand(I,ell,p);
--(gens trim (mm*I))% Jell
Js = rand(I,s,p);
M = module(I^r)/module(Js*I^(r-1));
time K = Js:I;
time minimalBetti M

time omega =  fastExt(s,K)

-----
code methods reesIdeal
uninstallPackage "ReesAlgebra"
installPackage "ReesAlgebra"
viewHelp ReesAlgebra


restart
load "residualDeterminantal.m2"
(p,n) = (2,4) 
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1)
R = ring I
L0 = ideal(I_0,I_5)+rand(I,1,2);
L = ideal apply(L0_*, a -> a^2);
K = L:I;
betti res trim K
gens(K^2)% (L*K)
M = (module K)/module ideal(I_0^2,I_5^2);
minimalBetti M -- doesn't work 
--error: input polynomials/vectors were computed in a non-compatible monomial order
prune Ext^2(M,S);
prune Hom(M,M)

---
--general statement
--assume I equigenerated for simplicity!
restart
load "residualDeterminantal.m2"

S = ZZ/101[a,b,c,d]    
I = ideal"ab,ac,bc,bd,d2"
I = ideal"ab2,ac2,bc2,bd2,d3"
betti res I
(K,M) = conj I
betti presentation M
M' = Ext^3(M,S^{-22})
H = Hom(M,M')
Hp = prune H
pmap = Hp.cache.pruningMap
target pmap
f = homomorphism(pmap*map(Hp,S^1, random(target presentation Hp,S^1)));
prune coker f
betti res M
betti res M'
betti res prune Hom(M,M)
codim K
omega = fastExt(3,K)
prune Hom(omega,omega)


restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFibeIdeal(I,I_0)
(K,M) = conj I;
betti prune M
betti prune Hom(M,M)


restart
--3 x 5 non-generic in 8 vars
load "residualDeterminantal.m2"
S = ZZ/101[a..h]
m = matrix"a,b,c,d,e;
       b,c,h,e,f;
       c,d,e,f,g"
I = minors(3,m)       
(sI,ell,r) = specialFibeIdeal(I,I_0)
(K,M) = conj I;
minimalBetti M
betti(H =  prune Hom(M,M))
minimalBetti H
omega = prune fastExt(6,K);
minimalBetti omega

restart
--4 x 5 non-generic in 4 vars
load "residualDeterminantal.m2"
S = ZZ/101[a..d]
L = flatten entries gens((ideal vars S)^2)

randm = ()->(
m := mutableMatrix map(S^4, S^{5:-2},(i,j)-> if i>j+1 then 0_S else L_(random 10));
apply (4, i-> m_(i,i) = S_i^2);
m_(3,2) = 0;
m_(3,3) = a;
m_(3,4) = b;
m = matrix m;
mi := apply(4, i->minors(i+1, m));
(m, mi/codim)
)

randm()

M=apply (1000, i->(
	(m, seq) = randm();
	if seq == {4,4,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)
m = M1_0
I = minors(4,m)
(sI,ell,r) = specialFibeIdeal(I,I_0)

(K,M) = conj I;
minimalBetti M
betti(H =  prune Hom(M,M))
minimalBetti H
omega = prune fastExt(6,K);
minimalBetti omega



--3 x 4 non-generic in 3 vars
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..c]
{*
L = flatten entries gens((ideal vars S)^2)
randm = ()->(
m := mutableMatrix map(S^3, S^{4:-2},(i,j)-> if i>j+1 then 0_S else L_(random 6));
apply (3, i-> m_(i,i) = S_i^2);
m_(2,1) = 0;
m_(2,2) = a;
m_(2,3) = b;
m = matrix m;
mi := apply(3, i->minors(i+1, m));
(m, mi/codim)
)

randm()
M=apply (1000, i->(
	(m, seq) = randm();
	if seq == {4,4,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)
m = M1_0
*}
m = matrix {{a^2, a*c, c^2, c^2}, {a*b, b^2, c^2, a^2}, {0, 0, a, b}}
I = minors(3,m)
--(sI,ell,r) = specialFibeIdeal(I,I_0)

(K,M) = conj I;
T = S/K
toT = map(T,S)
minimalBetti M

J = rand(I,2,5)
omega = prune ((module I)/module J) -- not iso to M
minimalBetti Hom(M,M)
M' = Ext^2(M,S^{-72})
H = Hom(M,M');


betti M
betti(H1 =  prune Hom(M,M)**S^{-35})
minimalBetti H1
omega = prune fastExt(6,K);
minimalBetti omega



Ibar = trim toT I
f = Ibar_0    
f = rand(Ibar,1,5)
f1 = rand(Ibar,1,5)

gens(Ibar^8) % (f*Ibar^7) == 0
gens(Ibar^7) % ((f^7*Ibar):Ibar^7) ==0
gens((f^(7)*Ibar^7):Ibar^7) % (Ibar^7) ==0

gens((f^13*Ibar):Ibar^7) % (Ibar^7) ==0
gens((Ibar^7)) %((f^13*Ibar):Ibar^7)  !=0

gens((f^12*Ibar):Ibar^7) % (Ibar^7) !=0
gens((Ibar^7)) %((f^12*Ibar):Ibar^7)  ==0

Ibar^7 : ((f^7*Ibar):Ibar^7)


g = rand((f^7*Ibar^7): (((f^7*Ibar):Ibar^7)),1,62)
(f^7*Ibar^7) == g*((f^7*Ibar):Ibar^7)

g1 = rand(Ibar,1,62);
(f^7*Ibar^7) == g1*((f^7*Ibar):Ibar^7)

------------------
--3 x 4 non-generic in 4 vars
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..d]

L = flatten entries gens((ideal vars S)^2)
randm = ()->(
m := mutableMatrix map(S^3, S^{4:-2},(i,j)-> if i>j+1 then 0_S else L_(random 10));
apply (3, i-> m_(i,i) = S_i^2);
m_(2,1) = 0;
m_(2,2) = a;
m_(2,3) = b;
m = matrix m;
mi := apply(3, i->minors(i+1, m));
(m, mi/codim)
)

randm()
M=apply (100, i->(
	(m, seq) = randm();
	if seq == {4,3,2} or seq =={3,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)

M2 = select(M1, m->(
I = minors(3,m);
(sI,ell,r) = specialFibeIdeal(I,I_0);
(ell == 3) and r>0 )
)

--3x4 example with 4 vars, ell = 3, r=7,
--found by the method above.
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..d]
m= matrix {{a^2, d^2, b^2, b*d}, {b*d, b^2, a^2, d^2}, {0, 0, a, b}}
I = minors(3,m)
I2 = minors(2,m)
I1 = minors(1,m)
{I1,I2,I}/codim -- codims 3,3,2
(K,M) = conj I;
--(ell, r) = (3,7)
minimalBetti M -- linear, 8,16,8, gen in degree 35

J = rand(I,2,5)
omega = prune ((module I)/module J) -- 2 gens; not iso to M
minimalBetti Hom(M,M) -- same resolution as M,
M' = Ext^2(M,S^{-72})
isIso(M,M') == true
betti(H1 =  prune Hom(M,M)**S^{-35})
isIso(M,H1) == true
--so M is iso to M', Hom(M,M)

netList primaryDecomposition I
netList I_*
