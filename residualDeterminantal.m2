{*
For generic determinantal ideals, 
Set:
q = n-p
s = p*q
r = p*q+1-p-q

If i>= reduction number (q-p-1 if p=2; in general) then I^i/JI^(i-1) \cong \omega_{R/K}. It is CM with
linear resolution, and self-dual.

for i>=r, and J generated by exactly s general elements it seems that I^i/JI^(i-1) is CM of codim s
and all isomorphic to omega_{R/K}, independent of i.

But in a MUCH wider range of cases I\subset S, it seems that if we set
ell = analyt spread I
r = reduction number I
K = (J:I) = (ell-1)-residual intersection, 
Ibar = 
-- M := I^ell/J*I^(ell-1) or M := Ibar^ell is MCM of codim ell-1;
-- M \cong I^(ell+j)/J*I^(ell+j-1) or Ibar^(ell+j)
-- M \cong Hom(M,M)
-- M is omega_{R/K} - self-dual. (this isomorphism seems strange and/or inhomogeneous)

In some cases also

-- M \cong omega_{R/K}
*}


load "SymmetricPower.m2"
needsPackage "ReesAlgebra"

--programs to extract the list of total betti numbers from a BettiTally
totalBetti = method()
totalBetti(ZZ,BettiTally) := (j,B) ->(
     Bj := select(keys B, k->k_0==j);
    sum(Bj, k->B#k))
totalBetti(ZZ,Module) := (j,M) -> (
    totalBetti(j, minimalBetti M))
totalBetti BettiTally := B->(
    len := max apply(keys B, k->k_0);
    apply(len+1, j -> totalBetti(j,B)))
totalBetti Module := M ->(
    totalBetti minimalBetti M)
totalBetti Ideal := I -> totalBetti minimalBetti I
totalBetti (ZZ,Ideal) := (j,I) -> totalBetti (j, minimalBetti I)

--kth power of p x p minors of generic p x n matrix (over a new ring)
detPower = {p,n,k} ->(
R := ZZ/101[x_(0,0)..x_(p-1,n-1)];
m := transpose genericMatrix(R, x_(0,0),n,p);
I := minors(p,m);
trim (I^k)
)

fastExt = (i,I) ->(
    --let R = ring I
    --returns Ext^i_R(R/I , R)
    --consider making this usage general.
    --should we minimize F.dd_(i+1)) and F.dd_(i) first?
    F := res(I, LengthLimit => i+1, FastNonminimal =>true);
    (kernel transpose F.dd_(i+1))/image transpose F.dd_(i)
    )

rand = (I,s,d) ->
    --s elements of degree d chosen at random from I
    --need a version that uses *all* the generators, works with hom, etc
    ideal ((gens I)*random(source gens I, (ring I)^{s:-d}))


redNumber = sI ->(
    param := rand(ideal vars ring sI, dim sI,1);
    N := (ring sI)^1/(sI+param);
    assert(dim N == 0);
    r':= 0;
    while hilbertFunction(i,N)!=0  do r' = r'+1;
    r'-1
    )

specialFiberInfo = (I,a) ->(
    --a \in I\subset S, a a nzd.
    --returs (sI,ell,r), the special fiber ideal, analytic spread, reduction number
    sI := specialFiberIdeal(I,a);
    ell := dim sI;
    r := redNumber sI;
    (sI,ell,r)
     )
    
{*
specialFibeIdeal = method()
specialFibeIdeal(Ideal,RingElement):= (I,x) ->(
     Reesi:= reesIdeal(I, x);
     S := ring Reesi;
     --is the coefficient ring of Reesi automatically flattened? NO
     kk := ultimate(coefficientRing, S);
     gS := gens S;
     T := kk[gS, Degrees => {#gS:1}];
     minimalpres := map(T,S);
     sI := trim minimalpres Reesi;
     ell := dim sI;
     r := redNumber sI;
     (sI,ell,r)
     )
*}

conj = I ->(
    --sets up the modules to test the conjecture.
    --ell = analyt spread I; r = reduction number I.
    --returns (K,M), where K = (J:I) and ell-1 residual intersection and
    -- M = I^r/JI^(r-1).
    d := degree(I_0);
    (sI,ell,r) := specialFiberInfo(I,I_0);
     <<(ell,r)<<endl;flush;
    J := rand(I,ell-1,d);
    (J:I,prune((module I^r)/module(J*I^(r-1))))
    )

conj' = I ->(
    --sets up the modules to test the conjecture.
    --ell = analyt spread I; r = reduction number I.
    --returns (K,M), where K = (J:I) and ell-1 residual intersection and
    -- M = I^r*(R^1/K)
    R := ring I;
    d := degree(I_0);
    (sI,ell,r) := specialFiberInfo(I,I_0);
     <<(ell,r)<<endl;flush;
    J := rand(I,ell-1,d);
    (J:I, prune(I^r*(R^1/K)))
    )

isIsoWithMap = (A,B)->(
    S := ring A;
    H := Hom(A,B);
    Hp := prune H;
    pmap := Hp.cache.pruningMap;
    f := homomorphism(pmap*map(Hp,S^1, random(target presentation Hp,S^1)));
    t := if prune coker f == 0 then true else false;
    (t,f))

isHomogeneousIso = (A,B)->(
    if not isHomogeneous A and isHomogeneous B then error"inputs not homogeneous";
	dA := degree A_*_0;
	dB := degree B_*_0;
	df := dB-dA;
        H := Hom(A,B);       
	kk := ultimate(coefficientRing, ring A);
	sH := select(H_*, f-> degree f == df);
	g := sum(sH, f-> random(kk)*homomorphism matrix f);
	return (prune coker (g**(coker vars S)) == 0 and prune ker g == 0)
	)
    

isLocalIso = (A,B)->(
    if isHomogeneous A and isHomogeneous B and
            all(A_*, a->degree a == degree(A_*_0)) and 
	    all(B_*, a->degree a == degree(B_*_0)) then
	return isHomogeneousIso(A,B);
	S := ring A; 
	kk := ultimate(coefficientRing, S);

        H1 := Hom(A,B);      
	g1 := sum(H1_*, f-> random(kk)*homomorphism matrix f);
	t1 = (prune coker g1 == 0);
    	if t1 == true then(
	    <<"there is a surjection arg1 -> arg2"<<endl;
            H2 := Hom(B,A);      
	    g2 := sum(H2_*, f-> random(kk)*homomorphism matrix f);
	    t2 = (prune coker g2 == 0);
	    t1 and t2)
    )
	
///
restart
load "residualDeterminantal.m2"
kk = ZZ/101
S = kk[x,y]
A = subquotient(matrix{{x}}, matrix{{x^2,y}})
prune A
B = S^{-2}**A
B' = B++B**S^{3}
isLocalIso(A,B)
isLocalIso(A,B')
isLocalIso(B',A)

isHomogeneousIso(A,B)
isHomogeneousIso(A,B')
isHomogeneousIso(B,A)

isLocalIso(A++A, A++S^{2}**A)
///


end--
viewHelp ReesAlgebra

restart
load "residualDeterminantal.m2"
--q := n-p
--look at depths of powers: (stab at value = analyt spread = (pn -p^2+1). 
--Note red num = pq-p-q+1 = (p-1)n-p^2+1
--2 x 4 matrix: R/det^i has depth 3 for all i>=2.
--2 x 5 matrix: R/det^i has depth 3 for all i>=2. pd's 7,7...
--2 x 6 matrix: R/det^i has pd 9 for all i>=2.
--3 x 5 -- pd's are 3,5,7,7...
--3 x 6 -- pd's 4,7,10...-- 

--test the depths of powers
(p,n) = (2,5) -- runs out of Heap for 3,6
num = 2
cod = n-p+1
I = apply(num, j->detPower(p,n,j+2));
apply (num, j->(
time	print pdim minimalBetti ((ring I_j)^1/I_j);
	flush;))

apply(num, j-> prune fastExt(cod+j+2,I_j))

--test whether the crucial I^r/JI^(r-1) is MCM of codim s
restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFiberInfo(I,I_0)

apply(1, u->(i = s;
I = detPower(p,n,1);
R= ring I;
J = ideal ((gens I)*random(source gens I, (ring I)^{i:-p}));
--print minimalBetti J;
print minimalBetti (module(I^r)/module(J*I^(r-1)));
))

--2 x n for n <= 7, the module I^r/JI^(r-1) has linear resolution of length s.
--3 x5 , the module I^r/JI^(r-1) has linear resolution of length s.
--3x5: we tried to compute the pd mod 5 general elements and it was slow


--J_ell and J_(ell-1)
restart
load "residualDeterminantal.m2"

(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1

I = detPower(p,n,1)
Jell = rand(I,ell,p)
Jell' = ideal((Jell_*)_{0..ell-2})
minimalBetti (module(Jell)/module(Jell'))
minimalBetti (rand(I,s,2):I)
minimalBetti Jell

--canonical module?
restart
load "residualDeterminantal.m2"
(p,n) = (2,4) -- runs out of Heap for 3,6
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1);
assert(s+1 == dim specialFiberIdeal(I,I_0))
mm = ideal vars ring I
Jell = rand(I,ell,p);
--(gens trim (mm*I))% Jell
Js = rand(I,s,p);
M = module(I^r)/module(Js*I^(r-1));
time K = Js:I;
time minimalBetti M

time omega =  fastExt(s,K)

-----
code methods reesIdeal
uninstallPackage "ReesAlgebra"
installPackage "ReesAlgebra"
viewHelp ReesAlgebra


restart
load "residualDeterminantal.m2"
(p,n) = (2,4) 
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1
cod = n-p+1
I = detPower(p,n,1)
R = ring I
L0 = ideal(I_0,I_5)+rand(I,1,2);
L = ideal apply(L0_*, a -> a^2);
K = L:I;
betti res trim K
gens(K^2)% (L*K)
M = (module K)/module ideal(I_0^2,I_5^2);
minimalBetti M -- doesn't work 
--error: input polynomials/vectors were computed in a non-compatible monomial order
prune Ext^2(M,S);
prune Hom(M,M)

---
--general statement
--assume I equigenerated for simplicity!
restart
load "residualDeterminantal.m2"

S = ZZ/101[a,b,c,d]    
I = ideal"ab,ac,bc,bd,d2"
I = ideal"ab2,ac2,bc2,bd2,d3"
betti res I
(K,M) = conj I
betti presentation M
M' = Ext^3(M,S^{-22})
H = Hom(M,M')
Hp = prune H
pmap = Hp.cache.pruningMap
target pmap
f = homomorphism(pmap*map(Hp,S^1, random(target presentation Hp,S^1)));
prune coker f
betti res M
betti res M'
betti res prune Hom(M,M)
codim K
omega = fastExt(3,K)
prune Hom(omega,omega)


restart
load "residualDeterminantal.m2"
(p,n) = (2,5)
q = n-p
s = p*q
r = p*q+1-p-q
ell = s+1

I = detPower(p,n,1);
(sI,ell,r) = specialFiberInfo(I,I_0)
(K,M) = conj I;
betti prune M
betti prune Hom(M,M)


restart
--3 x 5 non-generic in 8 vars
load "residualDeterminantal.m2"
S = ZZ/101[a..h]
m = matrix"a,b,c,d,e;
       b,c,h,e,f;
       c,d,e,f,g"
I = minors(3,m)       
(sI,ell,r) = specialFiberInfo(I,I_0)
(K,M) = conj I;
minimalBetti M
betti(H =  prune Hom(M,M))
minimalBetti H
omega = prune fastExt(6,K);
minimalBetti omega

restart
--4 x 5 non-generic in 4 vars
load "residualDeterminantal.m2"
S = ZZ/101[a..d]
L = flatten entries gens((ideal vars S)^2)

randm = ()->(
m := mutableMatrix map(S^4, S^{5:-2},(i,j)-> if i>j+1 or j>i+2 then 0_S else L_(random 10));
apply (4, i-> m_(i,i) = S_i^2);
m_(3,2) = 0;
m_(3,3) = a;
m_(3,4) = b;
m = matrix m;
mi := apply(4, i->minors(i+1, m));
(m, mi/codim)
)

randm()

M=apply (1000, i->(
	(m, seq) = randm();
	if seq == {4,4,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)
m = M1_0
I = minors(4,m)
--(sI,ell,r) = specialFiberInfo(I,I_0)

time (K,M) = conj I;
minimalBetti M
betti(H =  prune Hom(M,M))
minimalBetti H
omega = prune fastExt(6,K);
minimalBetti omega



--3 x 4 non-generic in 3 vars
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..c]
{*
L = flatten entries gens((ideal vars S)^2)
randm = ()->(
m := mutableMatrix map(S^3, S^{4:-2},(i,j)-> if i>j+1 then 0_S else L_(random 6));
apply (3, i-> m_(i,i) = S_i^2);
m_(2,1) = 0;
m_(2,2) = a;
m_(2,3) = b;
m = matrix m;
mi := apply(3, i->minors(i+1, m));
(m, mi/codim)
)

randm()
M=apply (1000, i->(
	(m, seq) = randm();
	if seq == {4,4,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)
m = M1_0
*}
m = matrix {{a^2, a*c, c^2, c^2}, {a*b, b^2, c^2, a^2}, {0, 0, a, b}}
I = minors(3,m)
--(sI,ell,r) = specialFiberInfo(I,I_0)

(K,M) = conj I;
T = S/K
toT = map(T,S)
minimalBetti M

J = rand(I,2,5)
omega = prune ((module I)/module J) -- not iso to M
minimalBetti Hom(M,M)
M' = Ext^2(M,S^{-72})
H = Hom(M,M');


betti M
betti(H1 =  prune Hom(M,M)**S^{-35})
minimalBetti H1
omega = prune fastExt(6,K);
minimalBetti omega



Ibar = trim toT I
f = Ibar_0    
f = rand(Ibar,1,5)
f1 = rand(Ibar,1,5)

gens(Ibar^8) % (f*Ibar^7) == 0
gens(Ibar^7) % ((f^7*Ibar):Ibar^7) ==0
gens((f^(7)*Ibar^7):Ibar^7) % (Ibar^7) ==0

gens((f^13*Ibar):Ibar^7) % (Ibar^7) ==0
gens((Ibar^7)) %((f^13*Ibar):Ibar^7)  !=0

gens((f^12*Ibar):Ibar^7) % (Ibar^7) !=0
gens((Ibar^7)) %((f^12*Ibar):Ibar^7)  ==0

Ibar^7 : ((f^7*Ibar):Ibar^7)


g = rand((f^7*Ibar^7): (((f^7*Ibar):Ibar^7)),1,62)
(f^7*Ibar^7) == g*((f^7*Ibar):Ibar^7)

g1 = rand(Ibar,1,62);
(f^7*Ibar^7) == g1*((f^7*Ibar):Ibar^7)

------------------
--3 x 4 non-generic in 4 vars
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..d]

L = flatten entries gens((ideal vars S)^2)
randm = ()->(
m := mutableMatrix map(S^3, S^{4:-2},(i,j)-> if i>j+1 then 0_S else L_(random 10));
apply (3, i-> m_(i,i) = S_i^2);
m_(2,1) = 0;
m_(2,2) = a;
m_(2,3) = b;
m = matrix m;
mi := apply(3, i->minors(i+1, m));
(m, mi/codim)
)

randm()
M=apply (100, i->(
	(m, seq) = randm();
	if seq == {4,3,2} or seq =={3,3,2} then (
	return m;
	break))
)
M1 = select(M, i-> i =!=null)

M2 = select(M1, m->(
I = minors(3,m);
(sI,ell,r) = specialFiberInfo(I,I_0);
(ell == 3) and r>0 )
)

--3x4 example with 4 vars, ell = 3, r=7,
--found by the method above. -- but actually only involves 3 vars.
restart
load "residualDeterminantal.m2"
S = ZZ/101[a..d]
--S = QQ[a..d]
--S = ZZ/32003[a..d]
m= matrix {{a^2, d^2, b^2, b*d}, {b*d, b^2, a^2, d^2}, {0, 0, a, b}}
I = minors(3,m)
I2 = minors(2,m)
I1 = minors(1,m)
{I1,I2,I}/codim -- codims 3,3,2
(K,M) = conj I;
--(ell, r) = (3,7)
betti res M -- linear, 8,16,8, gen in degree 35


J = rand(I,2,5)
omega = prune ((module I)/module J) -- 2 gens; not iso to M
codim K
omega' = Ext^2(S^1/K,S^1)
omega'**S^{-10}
isIso(omega, omega'**S^{-10}) == false -- huh??

minimalBetti Hom(M,M) -- same resolution as M,
M' = Ext^2(M,S^{-72})
isIso(M,M') == true
betti(H1 =  prune Hom(M,M)**S^{-35})
isIso(M,H1) == true
--so M is iso to M', Hom(M,M)

netList primaryDecomposition I
netList I_*

---------------
--monomial curve examples
--in P3:
restart
load "residualDeterminantal.m2"

S = ZZ/32003[a..d]
I = monomialCurveIdeal(S,{1,3,4})
(sI,ell, r) = specialFiberInfo(I, I_0)
J = rand(I,1,2)+rand(I,1,3)
K = J:I
M = prune(module(I^r)/module(J*I^(r-1)))
betti res M
betti res prune(Hom(M,M))
--self-dual, MCM iso omega, iso to End M.

restart
load "residualDeterminantal.m2"
--rational normal curves
d = 7
S = ZZ/32003[x_0..x_(d-1)]
I = monomialCurveIdeal(S,toList(1..d-1))
(sI,ell,r) = specialFiberInfo(I, I_0)
(ell,r) 
ell == d
r  -- (for d = 4,5,6,7, r = 0,1,3,3)
J=rand(I,ell-1,2);
time (K,M) = conj I;
minimalBetti K -- it's CM; but M is not omega.
minimalBetti M
betti res prune Hom(M,M) -- look 
omega = Ext^(d-1)(S^1/K,S^1) -- not iso M

--
restart
load "residualDeterminantal.m2"
--cusps of order delta
--delta = 1,2 give analyt indep generators
--delta = 3: it *seems* to work, 
--but only inhomogeneously.

d = 5
delta = 3
S = ZZ/32003[x_0..x_(d-1)]
exps = toList(1..d-2)|{d-1+delta}
I = monomialCurveIdeal(S,exps)
betti res I
degree I
(sI,ell,r) = specialFiberInfo(I, I_0)
(ell,r) == (4,2)

J=rand(I,2,2)+rand(I,1,3);
K = J:I
codim K == 3
codim(I+K) == 4
M = prune(module(I^r)/module(J*I^(r-1)));
betti (F = res M) -- CM but not homogeneously symmetric!
M' = coker transpose F.dd_3
H = Hom(M,M')
prune H
kk= coefficientRing S
random kk
f = sum(4, i->(random(kk)*homomorphism(H_{i})));
n
g = (matrix f)**(S^1/(ideal vars S))
isHomogeneous coker g
prune (M**(S^1/(ideal vars S)))
target g
cbar = (coker f)/((ideal vars S)*(coker f))

V = S/K
Ibarr = sub(I^r,V);
omega = sub(I,V);
A = omega_3 -- this is a nonzerodivisor of V
res ideal A
H1 = (A^2*Ibarr):((A^2*omega):Ibarr)
betti trim H1

--bug! this is isom to Hom, but prune Hom says 4 gens.
--for other reasons I know that the 4 gens of Hom
--are NOT all the homomorphisms.

C = sum(H1_*,B -> (random kk)*B);
0==gens (A^2*Ibarr) % (C*((A^2*omega):Ibarr)+(ideal vars V))
0==gens (C*((A^2*omega):Ibarr)) %((A^2*Ibarr)+(ideal vars V))

betti res I^2

betti res M'
prune Hom(M,M')
minimalBetti K -- it's CM; but M is not omega.
omega = prune Ext^(3)(S^1/K,S^1); -- not iso M
betti res omega
betti res prune Hom(M,M) -- look 

betti res omega

T = ring sI
U = T/sI
v2 = (vars U)_{0,1,2}
v3 = (vars U)_{3,4,5}
reg2 = ideal(v2*random(source v2, U^{2:-1}))
reg3 = ideal (v3*random(source v3, U^{1:-1}))
res (reg2+reg3)

----------------------------
--residual intersection in a codim 2 perfect
restart
load "residualDeterminantal.m2"
d = 4; n= 5;e = 1; kk = ZZ/101
S = kk[x_0..x_(d-1)]
--
m = map(S^n,S^{n+1:-e}, (i,j) -> if i<n-1 then random(kk)*x_(random(d)) else random(kk)*x_(random(d))^2)
minorss = apply(n, j->minors(j+1,m));
minorss/codim
--
m = matrix {{11*x_0, -16*x_2, -50*x_0, -26*x_0, -26*x_1, 0}, {35*x_1, 11*x_3, -15*x_0, -x_3, -13*x_1,
      -26*x_0}, {12*x_2, 5*x_1, -9*x_3, 19*x_0, -33*x_3, -21*x_3}, {33*x_1, -29*x_1, 40*x_3, -34*x_0, 12*x_2,
      40*x_1}, {40*x_0, -47*x_1, 49*x_1, 33*x_2, 25*x_3, 0}}


----POTENTIAL COUNTER-EXAMPLE: 5X6 MATRIX IN 4 VARS.
restart
load "residualDeterminantal.m2"
d = 4; n= 5;e = 1; kk = ZZ/101
S = kk[x_0..x_(d-1)]

m = matrix {{-9*x_1, 29*x_0, 17*x_1, -34*x_0, 28*x_2, -17*x_1}, {-24*x_1, 39*x_1, 45*x_3, -7*x_1,
       -30*x_1, 44*x_2}, {38*x_1, -42*x_1, x_2, 30*x_2, -42*x_2, 20*x_2}, {-19*x_1, -14*x_3, -22*x_2,
       6*x_2, 44*x_0, 32*x_2}, {36*x_1^2, 6*x_0^2, -19*x_3^2, -38*x_3^2, -29*x_1^2, 12*x_3^2}}
--ell == 4, 
--r == 6
--codims of i xi minors: {4,4,4,3,2}
I = minors(n,m);
J = rand(I,3,6);
J4 = rand(I,4,6);

M = module(I^6)/module(J*I^5);
time minimalBetti M
--o12 = total: 22 72 84 40 6
--         36: 22 72 84 40 6
--NOT self-dual, and not MCM.
--But

V = S/K
IV = sub(I,V)
IVS = prune pushForward(map(V,S),module (IV^6))
betti res IVS
--o22 = total: 16 48 48 16
--         36: 16 48 48 16

betti res Hom(IVS, IVS)
--is the same


--------------
--doesn't work with 1-residual int of certain codim 2 perfect ideals.
restart
load "residualDeterminantal.m2"
S = ZZ/101[x,y]
P = ideal vars S
--mlin =  random(S^1, S^{2:-1})
--mquad =  random(S^2, S^{2:-2})
--m = mlin||mquad
m = matrix"x2,0,y;0,y2,x"
isHomogeneous m
I = minors(2,m)
--specialFiberInfo(I,I_0) --here we have r = 1.
f1 = sum(I_*, g -> random(ZZ/101)*g)
f2 = sum(I_*, g -> random(ZZ/101)*g)
K = ideal(f1):I;
L = (ideal(f1,f2):I) -- the link
g = sum(L_*,h->random(ZZ/101)*h)
assert(0!=gens(L^2) % (K + g*L+ (ideal vars S)*L^2)) -- reduction number of L is >1.
--Bernd proves that for a perfect codim 2 ideal I with r= 1, such that
--Ibar is omega-self-dual, then the link L of I would have r = 1,
--which is not the case here.


(K,M) = conj I
betti (F = res M)
M/(P*M)
M' = coker transpose F.dd_1
M'/(P*M')
H = Hom(M,M')


--but 2-residual intersection seems to work.
restart
load "residualDeterminantal.m2"
S = ZZ/101[x,y,z]
mlin =  random(S^2, S^{3:-1})
mquad =  random(S^2, S^{3:-2}) -- get the 0 value in the assert for up to -8
m = mlin||mquad
I = minors(3,m)
codim minors(2,m)
--specialFiberInfo(I,I_0): ell = 3, r = 2
f1 = sum(I_*, g -> random(ZZ/101)*g)
f2 = sum(I_*, g -> random(ZZ/101)*g)
K = ideal(f1,f2):I;
L = ideal(m^{3})
g = sum(L_*,h->random(ZZ/101)*h)
assert(0==(gens(L^2) % (K + g*L+ (ideal vars S)*L^2)))
-- = 0
(K,M) = conj I
betti res M
betti res prune Hom(M,M)
betti res Ext^2(S^1/K,S^1)
isHomogeneous M
--

restart
load "residualDeterminantal.m2"
S = ZZ/101[x,y,z]
mlin =  random(S^3, S^{3:-1})
mquad =  random(S^3, S^{1:-3})
m = mlin|mquad
isHomogeneous m

I = minors(3,m)
betti m
codim minors(2,m)
--specialFiberInfo(I,I_0)
f1 = sum(I_*, g -> random(ZZ/101)*g)
f2 = sum(I_*, g -> random(ZZ/101)*g)
f3 = sum(I_*, g -> random(ZZ/101)*g)
J3 = ideal (f1,f2,f3)
J2 = ideal(f1,f2)
P = ideal vars S
(gens (I^3)) % (I^2*J3+P*I^3)

K = ideal(f1,f2):I;
L = J3:I
g = sum(L_*,h->random(ZZ/101)*h)
assert(0 == (gens(L^2) % (K + g*L+ P*L^2)))

