generate = method()
generate(List, ZZ) := List => (G,b) ->(
--G: list of positive ZZ.
--output: the list of elements of the semigroup generated by G at least up to b.
    G' = sort G;
    if min G' == 0 then G' = drop(G',1);
    e := min G';
    n := ceiling (b/e);
    for i from 1 to n do G' = unique sort flatten (G'|apply( G', g -> apply(G',h -> g+h)));
    G')
    
testForConductor = method()
testForConductor List := ZZ => G -> (
    --assumes that G is a sorted subset of a semigroup.
    --returns a number >= the conductor, if that is already in the list,
    --or else 0.
    e := min G;
    if e == 0 then G_1 else e; -- the multiplicity
    ell := #G;
    if last G - e == G_(ell-1)-e then last G else 0)
    
wilf = method()
wilf List := List => L -> (
    --return Apery set, conductor of the semigroup generated by L
    --uses the "circle of lights" method of wilf
    G = sort L; --make sure L is in order.
    k = #G;
    m = min G
    M = max G
    A = mutableList -- will be the Apery set
    S =new MutableHashTable from apply(k, i->(i%m,{}))
    apply(G, g -> S#(g%m) = S#(g%m)|{g})
    
    apply
    
    )
///
L = {5,7,16}
pairs S
///
end---
restart
load "semigroups.m2"


G = {10,11,14,15}
elapsedTime generate(G, 100)

G' = G
G' = unique sort flatten (G'|apply( G', g -> apply(G',h -> g+h)))
kk = ZZ/32003
S' = kk[x_1..x_7]
S = kk[x_0..x_7]
T = kk[t]
phi = map(T,S',apply(7, i-> if i <4 then t^(i+8) else t^(i+9)))
K' = ker phi
K = homogenize(sub(K',S), x_0)
isHomogeneous K
minimalBetti K
J = ideal ((gens K)*random(source gens K, S^{5:-2, -3}))
codim J
elapsedTime I = (J:K)
R = S/K
w = trim(I*R)
w2 = trim  w^2;
numgens w2
w3 = trim (w*w2)
numgens w3
w4 = trim (w*w3);
numgens w4

wS =  pushForward(map(R,S),module w)
minimalBetti wS

L = {0,8,9,10,11,13,14,15}
T = kk[s,t]
K = ker map(T,S,apply(L, i -> s^i*t^(15-i)))
minimalBetti K
